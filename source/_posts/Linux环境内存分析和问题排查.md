---
title: Linux环境性能优化和问题排查
date: 2018-11-22 00:14:05
categories:
- Linux Learning
tags:
- Linux
---

今天测试反馈了压测时内存占用较高，两个实例内存占用百分比有一定差距。看了下内存占用不一致估计是openApi调用的时候负载均衡的问题。之前的工作遇到类似的其实大部分都是运维处理的，今天自己去跳板机上排查了一遍，也学习了下内存分析的一些命令，学习了Linux环境下系统性能优化的大致思路，做一下记录。

<!--more-->

性能优化的核心是找出系统的瓶颈点，问题找到了，优化的工作也就完成了大半。主要从两个层面来追踪：

系统层面&程序层面；

**本文只介绍处理思路，更具体的命令使用和分析另行记录。**

## 1.分析系统瓶颈

首先得定位大致的问题出在哪里，是IO瓶颈、CPU瓶颈、内存瓶颈还是程序导致的系统问题；

使用top命令分析可以有一个较为全面的分析：

```shell
[app@VM_104_105_centos appsystems]$ top -M
top - 21:14:39 up 579 days,  1:12, 10 users,  load average: 0.00, 0.03, 0.06
Tasks: 245 total,   1 running, 177 sleeping,  67 stopped,   0 zombie
Cpu(s):  1.1%us,  1.6%sy,  3.6%ni, 93.6%id,  0.1%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:  7870.285M total, 7548.094M used,  322.191M free,   75.156M buffers
Swap:    0.000k total,    0.000k used,    0.000k free, 1831.695M cached

   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                   184164 root      26   6  654m  23m 6312 T 16.0  0.3 656:56.92 agent                     278926 root      20   0  432m  11m 2196 S  1.7  0.1  30:37.51 barad_agent                 3821 root      20   0  715m  17m 2760 S  1.3  0.2   1378:45 falcon-agent              70612 root      20   0  7144 6120  536 S  1.0  0.1 408:03.19 sap1002                    21269 root       7 -13  463m  19m 4588 S  0.7  0.3 183:23.85 daemon                    70617 root      20   0 39016  22m 5224 S  0.7  0.3 682:36.47 sap1009                    71929 root      20   0  577m 6996 2984 S  0.7  0.1   0:25.98 YDService                  92222 telegraf  20   0  507m  28m  10m S  0.7  0.4   4:59.52 telegraf                  70615 root      20   0 31464  13m  860 S  0.3  0.2 633:06.40 sap1005                    79110 influxdb  20   0  640m  64m 8768 S  0.3  0.8   0:43.95 influxd                   239464 app       20   0 5817m 2.3g  18m S  0.3 29.5   0:37.90 java        
```

`-M`: 该命令选项可以使用MB为单位展示内存使用情况。（部分版本不支持）

**进入交互模式后：**

 * 输入M：进程列表按内存占用降序排序（**%MEM字段**），便于观察最大内存使用者是否有问题，可以进一步跟踪确认是否有内存泄露的问题。
 * 输入P：进程列表按CPU占用降序排序（**%CPU字段**），便于观察最耗CPU资源的使用则是否有问题。

**第三行Cpu(s),显示当前cpu处理工作的情况，重点关注：**

 * %id：空闲CPU的时间百分比，如果这个值过低说明CPU存在瓶颈。
 * %wa：等待I/O的CPU时间百分比，这个值过高说明IO存在瓶颈。

## 2.分析内存瓶颈

top命令显示的内容较多，分析内存可以使用free命令：

```shell
[app@VM_104_105_centos appsystems]$ free -m
             total       used       free     shared    buffers     cached
Mem:          7870       7572        297          0         86       1805
-/+ buffers/cache:       5680       2189
Swap:            0          0          0
```

- `-m`表示以mb为单位展示内存使用情况，否则默认是KB单位；-g：表示以GB为单位；-s 2：表示每两秒更新一次内存情况，打印到控制台。

- Mem：内存使用情况
  - total：物理内存总大小
  - used：总的分配给缓存的（包含buffers&cache），可以部分缓存并未使用，所以不能拿这个数据当做实际的内存占用大小
  - free：未分配的内存
  - shared：共享内存一般系统都没有
  - cached：系统分配的但未被使用的cache大小。
  - **total（Mem） = used（Mem） + free（Mem）**
- buffers/cache：物理内存的缓存统计情况
  - used：去除buffers和cached的后**实际的内存占用量。=Mem_used - buffers - cached**
  - free：可以视为**真正空闲的内存大小。**
- Swap：交换区使用情况。

## 3.分析IO瓶颈

根据top命令，当%wa偏高时，系统的IO性能存在瓶颈，使用iostat命令分析：

```shell
[app@VM_104_105_centos logs]$ iostat -x -m
Linux 2.6.32-642.6.2.el6.x86_64 (VM_104_105_centos)  11/23/2018  _x86_64_ (4 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.53    0.02    0.31    0.08    0.00   99.06

Device:rrqm/s  wrqm/s   r/s   w/s  rMB/s  wMB/s avgrq-sz avgqu-sz   await  svctm  %util
vda    0.00    8.57    0.00  2.03  0.00    0.04    41.75     0.04   20.59   1.74   0.35
vdb    0.00    0.65    0.01  0.34  0.00    0.00    24.88     0.00    5.47   1.96   0.07
```

- 如果**%iowait**的值过高，表示硬盘存在I/O瓶颈。
- 如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。
- 如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；
- 如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。
- 如果avgqu-sz比较大，也表示有大量io在等待。

## 4.分析进程调用

通过top等工具发现系统性能问题是由某个进程导致的之后，接下来我们就需要分析这个进程,查询问题在哪；

这里我们有两个好用的工具： **pstack和pstrace**

pstack用来跟踪进程栈，这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方；

示例：查看bash程序进程栈:

```shell
/opt/app/tdev1$ps -fe| grep bash
tdev1   7013  7012  0 19:42 pts/1    00:00:00 -bash
tdev1  11402 11401  0 20:31 pts/2    00:00:00 -bash
tdev1  11474 11402  0 20:32 pts/2    00:00:00 grep bash
/opt/app/tdev1$pstack 7013
#0  0x00000039958c5620 in __read_nocancel () from /lib64/libc.so.6
#1  0x000000000047dafe in rl_getc ()
#2  0x000000000047def6 in rl_read_key ()
#3  0x000000000046d0f5 in readline_internal_char ()
#4  0x000000000046d4e5 in readline ()
#5  0x00000000004213cf in ?? ()
#6  0x000000000041d685 in ?? ()
#7  0x000000000041e89e in ?? ()
#8  0x00000000004218dc in yyparse ()
#9  0x000000000041b507 in parse_command ()
#10 0x000000000041b5c6 in read_command ()
#11 0x000000000041b74e in reader_loop ()
#12 0x000000000041b2aa in main ()
```

strace用来跟踪进程中的系统调用；这个工具能够动态的跟踪进程执行时的系统调用和所接收的信号。是一个非常有效的检测、指导和调试工具。系统管理员可以通过该命令容易地解决程序问题。

## Tips.什么是内存

内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。

内存(Memory)也被称为内存储器，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。

### 物理内存

**物理内存**指通过物理内存条而获得的内存空间。即随机存取存储器（random access memory，RAM），是与CPU直接交换数据的内部存储器，也叫主存(内存)。

### 虚拟内存

**虚拟内存**是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换（也就是说，当物理内存不足时，可能会借用硬盘空间来充当内存使用）。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。

###  Swap分区

Swap分区（即交换区）在系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。

###  buffer与cache的区别

1.cache：高速缓存，是位于CPU与主内存之间的一种容量较小但是速度较高的存储器，由于CPU的速度远高于主内存，CPU直接从内存中存取数据需要等待一定的时间周期。cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从cache中直接调用，这样就减少了CPU的等待时间，提高了系统的效率。
cache又分为一级cache(L1 cache)和二级cache(L2 cache),L1集成在CPU内部，L2早期一般时焊在主板上的，现在也都即成在CPU内部，常见L2 cache的容量有256KB或512KB。
2.buffer:缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少。速度快的设备可以利用buffer不间断的进行写操作，速度慢的设备可以直接从buffer中读取数据，减少速度快的设备的等待时间，提高效率。

* cache：文件系统的缓冲(page cache)，将常用的数据缓存起来供CPU使用。
* buffers:块设备的读写缓冲区(buffer cache)，缓冲满了一次写，提高IO性能。