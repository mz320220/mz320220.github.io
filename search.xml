<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker安装&amp;常用指令</title>
    <url>/2018/10/18/Docker%E5%AE%89%E8%A3%85&amp;%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>学习docker容器基本指令，以及尝试在docker中使用redis数据库。</p>
<span id="more"></span>

<h2 id="1-安装后启动报错"><a href="#1-安装后启动报错" class="headerlink" title="1.安装后启动报错"></a>1.安装后启动报错</h2><p>安装docker完毕后启动报错，提示“Hardware assisted vitrualization and data execution protection must be enabled in the BIOS”</p>
<p>这个错误大概率是由于磁盘没有开启虚拟化功能导致的。解决：</p>
<p>1、开机时按F2进入BIOS（不同机器可能会略有区别）</p>
<p>2、进入Security –&gt; Virtualization</p>
<p>3、调整Intel VT-Virtualization-Technology：<strong>Enabled</strong></p>
<h2 id="2-Docker常用命令"><a href="#2-Docker常用命令" class="headerlink" title="2.Docker常用命令"></a>2.Docker常用命令</h2><h3 id="2-1-docker镜像操作命令"><a href="#2-1-docker镜像操作命令" class="headerlink" title="2.1 docker镜像操作命令"></a>2.1 docker镜像操作命令</h3><ol>
<li>查看docker版本信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>docker镜像搜索（或在docker hub网页搜索）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search &#x27;image-name&#x27;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>镜像下载</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull &#x27;image-name&#x27;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>镜像删除</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi &#x27;image-name&#x27;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>删除所有镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure>



<h3 id="2-2-docker容器命令"><a href="#2-2-docker容器命令" class="headerlink" title="2.2 docker容器命令"></a>2.2 docker容器命令</h3><ol>
<li>启动一个镜像为容器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name &#x27;container-name&#x27; -d &#x27;image-name&#x27;</span><br><span class="line">docker run --help //查看run命令参数</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>查看docker中容器列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps	//查看运行中的容器</span><br><span class="line">docker ps -a //查看运行、停止状态的容器</span><br></pre></td></tr></table></figure></li>
<li><p>停止&amp;启动容器</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop &#x27;container-name/id&#x27;</span><br><span class="line">docker start &#x27;container-name/id&#x27;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>容器端口映射</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//启动一个叫port-redis的容器，映射容器6379端口到本机6378</span><br><span class="line">docker run -d -p 6378:6379 --name port-redis redis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>windows下运行的docker实际上是在虚拟机中，上述的端口映射是docker–&gt;虚拟机，如果想在本地开发环境使用，还需要一次映射：虚拟机–&gt;开发机</p>
</blockquote>
<ol start="5">
<li>删除容器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm &#x27;container-name/id&#x27;</span><br><span class="line">docker rm $(docker ps -a -q)	//删除所有容器</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>容器日志</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs &#x27;container-name/id&#x27;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>登录容器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it &#x27;container-name/id&#x27; bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行中的容器实际上相当于一个完备的Linux系统，可以登录后进行常规Linux命令操作</p>
</blockquote>
<ol start="8">
<li>登录后查看容器信息</li>
</ol>
<p>按上述登录到容器中后就可以按Linux的命令如hostname、env、ip addr等进行查看容器的信息。补充另外另种方式：</p>
<ul>
<li>不用进入容器，直接通过命令查看</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec &#x27;container-name/id&#x27; hostname</span><br><span class="line">docker exec &#x27;container-name/id&#x27; env</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<strong>inspect</strong>命令，可以获得全部内容</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect &#x27;container-name/id&#x27;</span><br><span class="line">docker inspect -f &#123;&#123;.NetworkSettings.IPAddress&#125;&#125; &#x27;container-name/id&#x27;</span><br><span class="line">docker inspect &#x27;container-name/id&#x27;| grep IPAddress</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-f：format指令可以设定具体的属性内容 :slightly_smiling_face:</p>
<p>inspect命令结合grep使用快速查询容器属性！</p>
</blockquote>
<h2 id="3-虚拟机端口映射配置"><a href="#3-虚拟机端口映射配置" class="headerlink" title="3. 虚拟机端口映射配置"></a>3. 虚拟机端口映射配置</h2><p>上面介绍了docker容器的端口映射，在windows下还要进行虚拟机到一般开发环境的端口映射才可以正常访问容器。以redis为例说明：</p>
<h3 id="3-1虚拟机端口映射到容器端口"><a href="#3-1虚拟机端口映射到容器端口" class="headerlink" title="3.1虚拟机端口映射到容器端口"></a>3.1虚拟机端口映射到容器端口</h3><ol>
<li>开启容器并映射<strong>虚拟机port：容器port</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name test-redis redis</span><br><span class="line">-p：小写表示指示具体的端口映射</span><br><span class="line">-P：大写表示随机分配主机端口映射到容器开放的网络端口上。</span><br></pre></td></tr></table></figure>

<p>将虚拟机的6379端口映射到容器6379端口</p>
<ol start="2">
<li>映射时指定ip地址</li>
</ol>
<p>一般不需要特别指定虚拟机ip地址，默认0.0.0.0，也可以在绑定时指定：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:6379:6379 --name test-redis redis</span><br><span class="line"><span class="meta">#</span><span class="bash">启动结果如下</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             </span><br><span class="line">2aedbac0a984        redis               &quot;docker-entrypoint.s…&quot;   4 seconds ago       </span><br><span class="line"></span><br><span class="line">STATUS              PORTS                      NAMES	</span><br><span class="line">Up 3 seconds        127.0.0.1:6379-&gt;6379/tcp   test-redis</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>映射时可以指定通信协议tcp、udp</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:6379:6379/tcp --name test-redis redis</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查看容器端口绑定&amp;IP地址</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker port test-redis</span><br><span class="line"><span class="meta">#</span><span class="bash">结果：容器端口映射到虚拟机127.0.0.1:6379</span></span><br><span class="line">6379/tcp -&gt; 127.0.0.1:6379</span><br><span class="line"></span><br><span class="line">docker inspect test-redis|grep &#x27;IPAddress&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">结果</span></span><br><span class="line">&quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">&quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">&quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果想要同时绑定多个端口，则使用多个-p指令即可</p>
<p>除了启动容器时绑定port，也可以通过宿主机的iptables进行nat转发实现，详见：<a href="https://blog.csdn.net/mnasd/article/details/83087881">docker-redis</a></p>
</blockquote>
<h3 id="3-2映射本机端口到虚拟机端口"><a href="#3-2映射本机端口到虚拟机端口" class="headerlink" title="3.2映射本机端口到虚拟机端口"></a>3.2映射本机端口到虚拟机端口</h3><p>如果想要在本机上使用，还需要进行本机端口–&gt;虚拟机端口映射的操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.查看目前端口的映射情况</span></span><br><span class="line">netsh interface portproxy show v4tov4</span><br><span class="line">netsh interface portproxy show v4tov4 | find &quot;127.0.0.1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">2.增加一个端口映射,listen主机IP&amp;port --&gt; connect 虚拟机IP&amp;port</span></span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=127.0.0.1 listenport=6379 connectaddress=127.0.0.1 connectport=6379</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">3.删除一个端口映射</span></span><br><span class="line">netsh interface portproxy delete v4tov4 listenaddress=/address listenport=/port</span><br></pre></td></tr></table></figure>

<h2 id="4-Docker中使用redis"><a href="#4-Docker中使用redis" class="headerlink" title="4. Docker中使用redis"></a>4. Docker中使用redis</h2><p>经过以上的操作我们直接通过127.0.0.1:6379即可连接redis。我们也可以直接登录容器操作redis数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.进入docker的redis-cli环境</span></span><br><span class="line">docker exec -it &#x27;container-name/id&#x27; redis-cli</span><br><span class="line"><span class="meta">#</span><span class="bash">例如：</span></span><br><span class="line">docker exec -it test-redis redis-cli</span><br><span class="line"><span class="meta">#</span><span class="bash">进入如下界面即可使用redis命令，如：keys、get、ttl等，退出使用<span class="built_in">exit</span>即可</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>Github+hexo搭建博客指南</title>
    <url>/2018/03/19/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-9-22/51716129.jpg" alt="17.11.27-花莲"></p>
<p>博客搭好一段时间了，一直也没有写点东西，目前网上已经有很完整的Github + Hexo搭建博客的教程，本文仅列出基本指令和搭建过程中参考的指南以作备忘。</p>
<span id="more"></span>

<h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>即文章开头预设可设置参数，具体如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
<td></td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签（不适用于分页）</td>
<td></td>
</tr>
<tr>
<td>categories</td>
<td>分类（不适用于分页）</td>
<td></td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章网址</td>
<td></td>
</tr>
</tbody></table>
<h2 id="发表博文"><a href="#发表博文" class="headerlink" title="发表博文"></a>发表博文</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;postTitle&quot; == hexo new &quot;我的博客&quot; //新建文章(默认为post模式)</span><br><span class="line">hexo p == hexo publish  //草稿发布(draft类型)</span><br><span class="line">hexo g == hexo generate //生成</span><br><span class="line">hexo d == hexo deploy   //部署</span><br><span class="line">hexo d -g == hexo deploy --generate //生成 + 部署</span><br></pre></td></tr></table></figure>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s == hexo server   //本地启动服务预览，hexo会监听文件变更无需重启</span><br><span class="line">hexo server -s          //静态模式</span><br><span class="line">hexo server -p 5000     //更改端口</span><br><span class="line">hexo server -i 192.168.1.1  //自定义 IP</span><br></pre></td></tr></table></figure>
<p>在写完博客以后，可以先本地验证一下：<code>hexo s</code></p>
<p>发现问题修改保存后，静态内容可以直接生效，否则需要重新生成启动服务：<code>hexo s -g</code></p>
<p>验证完毕后即可推送到线上：<code>hexo d -g</code></p>
<h1 id="框架具体搭建过程"><a href="#框架具体搭建过程" class="headerlink" title="框架具体搭建过程"></a>框架具体搭建过程</h1><blockquote>
<p>参考文档<br></p>
</blockquote>
<p><a href="https://hexo.io/zh-cn/docs/front-matter.html">hexo官方文档</a><br><br><a href="http://cherryblog.site/Use-Gitpagehexo-to-develop-their-own-blog.html">利用 hexo + Gitpage 开发自己的博客</a></p>
]]></content>
      <categories>
        <category>hexo建站</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>git及intellij idea设置代理</title>
    <url>/2019/04/18/Git%E5%8F%8Aintellij-idea%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>除了在某些情况需要在天朝科学上网之外，各大公司普遍推动使用VDI云桌面也是全局性的走代理上网。那么从github上拉取代码就必须要对git和IDE单独配置代理服务器。</p>
<span id="more"></span>

<h2 id="1-Git设置代理"><a href="#1-Git设置代理" class="headerlink" title="1. Git设置代理"></a>1. Git设置代理</h2><ul>
<li><p>使用 <code>git协议</code> 时，设置代理需要配置 <code>core.gitproxy</code></p>
</li>
<li><p>使用 <code>HTTP协议</code> 时，设置代理需要配置 <code>http.proxy</code></p>
</li>
<li><p>而是用 <code>ssh协议</code> 时，代理需要配置ssh的 <code>ProxyCommand</code> 参数</p>
</li>
</ul>
<p>在windows环境下，配置http方式的代理是最为简单方便的了。公司的vdi代理一般也是提供http协议address + port的形式。下面说明<code>http.proxy</code>的配置命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">针对单个项目进行代理配置：（进入到项目目录）</span></span><br><span class="line">git config http.proxy http://127.0.0.1:8088  #URL:PORT 或 URI:PORT的形式</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">需要鉴权的代理：添加username、password信息</span></span><br><span class="line">git config http.proxy http://username:password@127.0.0.1:8088</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">启用全局代理（公司的VDI环境直接全局配置比较合适） --global指令</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:8088</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看代理配置情况</span></span><br><span class="line">git config --get --global http.proxy</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">删除原有代理配置 --<span class="built_in">unset</span>指令</span></span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果https协议出现证书错误的情况，比如提示： SSL certificate problem</span></span><br><span class="line"><span class="meta">#</span><span class="bash">可以尝试将sslVerify设置为<span class="literal">false</span></span></span><br><span class="line">git config --global http.sslVerify false</span><br></pre></td></tr></table></figure>

<p>几点说明：</p>
<ul>
<li><p>如果非必要，一般不使用 <code>--global</code> 的方式来设置代理，毕竟代理有的时候访问一些项目比直接访问还慢，特别是当代理在国外，项目源在国内的时候，按需使用才是王道。</p>
</li>
<li><p>不要多次使用不同的参数来设置代理， <code>--global</code> ， <code>--system</code> ， <code>--local</code> 各级设置后，可能会给自己带来不必要的麻烦。git默认是先到git Repository的配置文件中查找配置文件，如果没有才会到 <code>--global</code> 设置的文件中查找，因此，单个项目文件中的设置会覆盖 <code>--global</code> 的设置。</p>
</li>
<li><p>使用 <code>--global</code> 来配置的信息保存在当前用户的根目录下的 <code>.config</code> 文件中，而仓库中的配置保存在项目仓库的根目录下的 <code>.git/config</code> 文件中。</p>
</li>
</ul>
<h2 id="2-intellij-idea设置代理"><a href="#2-intellij-idea设置代理" class="headerlink" title="2. intellij idea设置代理"></a>2. intellij idea设置代理</h2><p>同样的问题，在VDI环境下所有软件都是需要自己手动配置代理信息，否则也无法拉去代码使用IDE的代码管理功能。以Intellij idea举例，快捷键 <code>Ctrl + Alt + S</code>打开设置窗口，输入<code>http</code>进入如下代理设置页面：</p>
<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/19-4-18/intellij%E4%BB%A3%E7%90%86.png?Expires=1555582022&OSSAccessKeyId=TMP.AgHyuUNIJaNN5_913dyKrg-GhAE6NCPDN6o2x-MgsVpJxo7nTf175B8NTrXKADAtAhRm3eG6rtWyCoOxwQpOHH49v6U2KgIVAMcBjCxr3zYBCcLqOI_TRaXQaMoM&Signature=AyN4EpzuYhow97Rt/h30t8rS+r8=" alt="intellij代理"></p>
<p>按要求配置后重启IDE即可登录配置git账号，拉取项目代码。</p>
<blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/lenglong110/article/details/52411230">windows下设置git代理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>git</category>
        <category>IDE</category>
      </categories>
  </entry>
  <entry>
    <title>Linux环境性能优化和问题排查</title>
    <url>/2018/11/22/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%92%8C%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<p>今天测试反馈了压测时内存占用较高，两个实例内存占用百分比有一定差距。看了下内存占用不一致估计是openApi调用的时候负载均衡的问题。之前的工作遇到类似的其实大部分都是运维处理的，今天自己去跳板机上排查了一遍，也学习了下内存分析的一些命令，学习了Linux环境下系统性能优化的大致思路，做一下记录。</p>
<span id="more"></span>

<p>性能优化的核心是找出系统的瓶颈点，问题找到了，优化的工作也就完成了大半。主要从两个层面来追踪：</p>
<p>系统层面&amp;程序层面；</p>
<p><strong>本文只介绍处理思路，更具体的命令使用和分析另行记录。</strong></p>
<h2 id="1-分析系统瓶颈"><a href="#1-分析系统瓶颈" class="headerlink" title="1.分析系统瓶颈"></a>1.分析系统瓶颈</h2><p>首先得定位大致的问题出在哪里，是IO瓶颈、CPU瓶颈、内存瓶颈还是程序导致的系统问题；</p>
<p>使用top命令分析可以有一个较为全面的分析：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[app@VM_104_105_centos appsystems]$ top -M</span><br><span class="line">top - 21:14:39 up 579 days,  1:12, 10 users,  load average: 0.00, 0.03, 0.06</span><br><span class="line">Tasks: 245 total,   1 running, 177 sleeping,  67 stopped,   0 zombie</span><br><span class="line">Cpu(s):  1.1%us,  1.6%sy,  3.6%ni, 93.6%id,  0.1%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:  7870.285M total, 7548.094M used,  322.191M free,   75.156M buffers</span><br><span class="line">Swap:    0.000k total,    0.000k used,    0.000k free, 1831.695M cached</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                   184164 root      26   6  654m  23m 6312 T 16.0  0.3 656:56.92 agent                     278926 root      20   0  432m  11m 2196 S  1.7  0.1  30:37.51 barad_agent                 3821 root      20   0  715m  17m 2760 S  1.3  0.2   1378:45 falcon-agent              70612 root      20   0  7144 6120  536 S  1.0  0.1 408:03.19 sap1002                    21269 root       7 -13  463m  19m 4588 S  0.7  0.3 183:23.85 daemon                    70617 root      20   0 39016  22m 5224 S  0.7  0.3 682:36.47 sap1009                    71929 root      20   0  577m 6996 2984 S  0.7  0.1   0:25.98 YDService                  92222 telegraf  20   0  507m  28m  10m S  0.7  0.4   4:59.52 telegraf                  70615 root      20   0 31464  13m  860 S  0.3  0.2 633:06.40 sap1005                    79110 influxdb  20   0  640m  64m 8768 S  0.3  0.8   0:43.95 influxd                   239464 app       20   0 5817m 2.3g  18m S  0.3 29.5   0:37.90 java        </span><br></pre></td></tr></table></figure>

<p><code>-M</code>: 该命令选项可以使用MB为单位展示内存使用情况。（部分版本不支持）</p>
<p><strong>进入交互模式后：</strong></p>
<ul>
<li>输入M：进程列表按内存占用降序排序（**%MEM字段**），便于观察最大内存使用者是否有问题，可以进一步跟踪确认是否有内存泄露的问题。</li>
<li>输入P：进程列表按CPU占用降序排序（**%CPU字段**），便于观察最耗CPU资源的使用则是否有问题。</li>
</ul>
<p><strong>第三行Cpu(s),显示当前cpu处理工作的情况，重点关注：</strong></p>
<ul>
<li>%id：空闲CPU的时间百分比，如果这个值过低说明CPU存在瓶颈。</li>
<li>%wa：等待I/O的CPU时间百分比，这个值过高说明IO存在瓶颈。</li>
</ul>
<h2 id="2-分析内存瓶颈"><a href="#2-分析内存瓶颈" class="headerlink" title="2.分析内存瓶颈"></a>2.分析内存瓶颈</h2><p>top命令显示的内容较多，分析内存可以使用free命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[app@VM_104_105_centos appsystems]$ free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          7870       7572        297          0         86       1805</span><br><span class="line">-/+ buffers/cache:       5680       2189</span><br><span class="line">Swap:            0          0          0</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>-m</code>表示以mb为单位展示内存使用情况，否则默认是KB单位；-g：表示以GB为单位；-s 2：表示每两秒更新一次内存情况，打印到控制台。</p>
</li>
<li><p>Mem：内存使用情况</p>
<ul>
<li>total：物理内存总大小</li>
<li>used：总的分配给缓存的（包含buffers&amp;cache），可以部分缓存并未使用，所以不能拿这个数据当做实际的内存占用大小</li>
<li>free：未分配的内存</li>
<li>shared：共享内存一般系统都没有</li>
<li>cached：系统分配的但未被使用的cache大小。</li>
<li><strong>total（Mem） = used（Mem） + free（Mem）</strong></li>
</ul>
</li>
<li><p>buffers/cache：物理内存的缓存统计情况</p>
<ul>
<li>used：去除buffers和cached的后<strong>实际的内存占用量。=Mem_used - buffers - cached</strong></li>
<li>free：可以视为<strong>真正空闲的内存大小。</strong></li>
</ul>
</li>
<li><p>Swap：交换区使用情况。</p>
</li>
</ul>
<h2 id="3-分析IO瓶颈"><a href="#3-分析IO瓶颈" class="headerlink" title="3.分析IO瓶颈"></a>3.分析IO瓶颈</h2><p>根据top命令，当%wa偏高时，系统的IO性能存在瓶颈，使用iostat命令分析：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[app@VM_104_105_centos logs]$ iostat -x -m</span><br><span class="line">Linux 2.6.32-642.6.2.el6.x86_64 (VM_104_105_centos)  11/23/2018  _x86_64_ (4 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.53    0.02    0.31    0.08    0.00   99.06</span><br><span class="line"></span><br><span class="line">Device:rrqm/s  wrqm/s   r/s   w/s  rMB/s  wMB/s avgrq-sz avgqu-sz   await  svctm  %util</span><br><span class="line">vda    0.00    8.57    0.00  2.03  0.00    0.04    41.75     0.04   20.59   1.74   0.35</span><br><span class="line">vdb    0.00    0.65    0.01  0.34  0.00    0.00    24.88     0.00    5.47   1.96   0.07</span><br></pre></td></tr></table></figure>

<ul>
<li>如果**%iowait**的值过高，表示硬盘存在I/O瓶颈。</li>
<li>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。</li>
<li>如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；</li>
<li>如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。</li>
<li>如果avgqu-sz比较大，也表示有大量io在等待。</li>
</ul>
<h2 id="4-分析进程调用"><a href="#4-分析进程调用" class="headerlink" title="4.分析进程调用"></a>4.分析进程调用</h2><p>通过top等工具发现系统性能问题是由某个进程导致的之后，接下来我们就需要分析这个进程,查询问题在哪；</p>
<p>这里我们有两个好用的工具： <strong>pstack和pstrace</strong></p>
<p>pstack用来跟踪进程栈，这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方；</p>
<p>示例：查看bash程序进程栈:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">/opt/app/tdev1$</span><span class="bash">ps -fe| grep bash</span></span><br><span class="line">tdev1   7013  7012  0 19:42 pts/1    00:00:00 -bash</span><br><span class="line">tdev1  11402 11401  0 20:31 pts/2    00:00:00 -bash</span><br><span class="line">tdev1  11474 11402  0 20:32 pts/2    00:00:00 grep bash</span><br><span class="line"><span class="meta">/opt/app/tdev1$</span><span class="bash">pstack 7013</span></span><br><span class="line"><span class="meta">#</span><span class="bash">0  0x00000039958c5620 <span class="keyword">in</span> __read_nocancel () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x000000000047dafe <span class="keyword">in</span> rl_getc ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2  0x000000000047def6 <span class="keyword">in</span> rl_read_key ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">3  0x000000000046d0f5 <span class="keyword">in</span> readline_internal_char ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">4  0x000000000046d4e5 <span class="keyword">in</span> readline ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5  0x00000000004213cf <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6  0x000000000041d685 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">7  0x000000000041e89e <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">8  0x00000000004218dc <span class="keyword">in</span> yyparse ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">9  0x000000000041b507 <span class="keyword">in</span> parse_command ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">10 0x000000000041b5c6 <span class="keyword">in</span> read_command ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">11 0x000000000041b74e <span class="keyword">in</span> reader_loop ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">12 0x000000000041b2aa <span class="keyword">in</span> main ()</span></span><br></pre></td></tr></table></figure>

<p>strace用来跟踪进程中的系统调用；这个工具能够动态的跟踪进程执行时的系统调用和所接收的信号。是一个非常有效的检测、指导和调试工具。系统管理员可以通过该命令容易地解决程序问题。</p>
<h2 id="Tips-什么是内存"><a href="#Tips-什么是内存" class="headerlink" title="Tips.什么是内存"></a>Tips.什么是内存</h2><p>内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。</p>
<p>内存(Memory)也被称为内存储器，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。</p>
<h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><p><strong>物理内存</strong>指通过物理内存条而获得的内存空间。即随机存取存储器（random access memory，RAM），是与CPU直接交换数据的内部存储器，也叫主存(内存)。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换（也就是说，当物理内存不足时，可能会借用硬盘空间来充当内存使用）。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。</p>
<h3 id="Swap分区"><a href="#Swap分区" class="headerlink" title="Swap分区"></a>Swap分区</h3><p>Swap分区（即交换区）在系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。</p>
<h3 id="buffer与cache的区别"><a href="#buffer与cache的区别" class="headerlink" title="buffer与cache的区别"></a>buffer与cache的区别</h3><p>1.cache：高速缓存，是位于CPU与主内存之间的一种容量较小但是速度较高的存储器，由于CPU的速度远高于主内存，CPU直接从内存中存取数据需要等待一定的时间周期。cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从cache中直接调用，这样就减少了CPU的等待时间，提高了系统的效率。<br>cache又分为一级cache(L1 cache)和二级cache(L2 cache),L1集成在CPU内部，L2早期一般时焊在主板上的，现在也都即成在CPU内部，常见L2 cache的容量有256KB或512KB。<br>2.buffer:缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少。速度快的设备可以利用buffer不间断的进行写操作，速度慢的设备可以直接从buffer中读取数据，减少速度快的设备的等待时间，提高效率。</p>
<ul>
<li>cache：文件系统的缓冲(page cache)，将常用的数据缓存起来供CPU使用。</li>
<li>buffers:块设备的读写缓冲区(buffer cache)，缓冲满了一次写，提高IO性能。</li>
</ul>
]]></content>
      <categories>
        <category>Linux Learning</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown入门 &amp; Typora编辑器</title>
    <url>/2018/09/21/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p><a href="#jumpTypora">从发现了一个超级好用的markdown编辑软件-Typora</a> <span id = "jumpTop">开始</span></p>
</blockquote>
<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更加强大，因此有很多人用它写博客。世界上最流行的博客平台<a href="https://baike.baidu.com/item/WordPress">WordPress</a>和大型CMS如<a href="https://baike.baidu.com/item/Joomla">Joomla</a>、<a href="https://baike.baidu.com/item/Drupal">Drupal</a>都能很好的支持Markdown。</p>
<span id="more"></span>

<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><h2 id="1-块元素"><a href="#1-块元素" class="headerlink" title="1.块元素"></a>1.块元素</h2><h3 id="1-1标题"><a href="#1-1标题" class="headerlink" title="1.1标题"></a>1.1标题</h3><p>markdown中使用1-6个<code>#</code>符号来表示不同层级的标题，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<h3 id="1-2-引用"><a href="#1-2-引用" class="headerlink" title="1.2 引用"></a>1.2 引用</h3><p>markdown使用<code>&gt;</code>符号来引用问题，多个<code>&gt;</code>符号表示不同的引用的嵌套，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 这是一个引用</span><br><span class="line">&gt; </span><br><span class="line">&gt;&gt; 这是嵌套的引用语句</span><br></pre></td></tr></table></figure>

<h3 id="1-3-列表"><a href="#1-3-列表" class="headerlink" title="1.3 列表"></a>1.3 列表</h3><p>输入<code>*</code>可以表示一个无序列表，使用<code>+</code>或<code>-</code>可以实现同样的功能；</p>
<p>输入<code>1.</code>可以生成一个有序列表，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 无序节点</span><br><span class="line">* 无序节点</span><br><span class="line">	- 子无序节点</span><br><span class="line">	- 子无序节点</span><br><span class="line"></span><br><span class="line">1. 有序节点</span><br><span class="line">2. 有序节点</span><br></pre></td></tr></table></figure>

<h3 id="1-4-代办事项"><a href="#1-4-代办事项" class="headerlink" title="1.4 代办事项"></a>1.4 代办事项</h3><p>代办事项可以通过<code>- [ ]</code>或<code>- [X]</code>分别表示未完成或已完成事项，书写的使用注意空格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [ ] 未完成任务</span><br><span class="line">- [X] 已完成任务</span><br></pre></td></tr></table></figure>

<h3 id="1-5-代码块"><a href="#1-5-代码块" class="headerlink" title="1.5 代码块"></a>1.5 代码块</h3><p>markdown使用```来表示代码块，可以通过制定代码类型来显示不同的高亮风格，针对不同类型的代码只需要在```后面加上java、python等描述即可。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是一个Java风格的代码块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-表格"><a href="#1-6-表格" class="headerlink" title="1.6 表格"></a>1.6 表格</h3><p>输入<code>| firse header | second header |</code>可以生成一个两列的表格；<br>表格的对齐方式如下，详细代码如示例：</p>
<p><code>:----</code> ：左对齐</p>
<p><code>:----:</code>：居中对齐</p>
<p><code>----:</code>：右对齐</p>
<p><code>----</code>：默认为居中对齐</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Left-Aligned  | Center Aligned  | Right Aligned |</span><br><span class="line">| :------------ |:---------------:| -----:|</span><br><span class="line">| col 3 is      | some wordy text | $1600 |</span><br><span class="line">| col 2 is      | centered        |   $12 |</span><br><span class="line">| zebra stripes | are neat        |    $1 |</span><br></pre></td></tr></table></figure>

<p>以上代码在markdown中表现的表格为：</p>
<table>
<thead>
<tr>
<th align="left">Left-Aligned</th>
<th align="center">Center Aligned</th>
<th align="right">Right Aligned</th>
</tr>
</thead>
<tbody><tr>
<td align="left">col 3 is</td>
<td align="center">some wordy text</td>
<td align="right">$1600</td>
</tr>
<tr>
<td align="left">col 2 is</td>
<td align="center">centered</td>
<td align="right">$12</td>
</tr>
<tr>
<td align="left">zebra stripes</td>
<td align="center">are neat</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<h3 id="1-7-注脚"><a href="#1-7-注脚" class="headerlink" title="1.7 注脚"></a>1.7 注脚</h3><p>注脚通常用于在需要解释名词、书名、人名等时使用，markdown中注脚的表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建一个注脚测试[^footnote].</span><br><span class="line">[^footnote]: 这是一个针对注脚的测试。</span><br></pre></td></tr></table></figure>
<p>以上代码在markdown中的表现为：</p>
<p>创建一个注脚测试。<a href="%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F%EF%BC%81">^1</a></p>
<h3 id="1-8-分割线"><a href="#1-8-分割线" class="headerlink" title="1.8 分割线"></a>1.8 分割线</h3><p>使用<code>***</code> 或 <code>---</code> <code>+++</code> 创建一条分割线</p>
<p>在使用这些符号是大于三个即可组成一条平行线，注意在使用<code>---</code>时前后空格，避免被当做题记的标记。</p>
<h3 id="1-9-生成目录"><a href="#1-9-生成目录" class="headerlink" title="1.9 生成目录"></a>1.9 生成目录</h3><p>输入<code>[toc]</code>即可在需要的位置生成一个目录，该目录自动抓取所有标题，且会自动更新。</p>
<h2 id="2-行内元素"><a href="#2-行内元素" class="headerlink" title="2. 行内元素"></a>2. 行内元素</h2><h3 id="2-1-链接"><a href="#2-1-链接" class="headerlink" title="2.1 链接"></a>2.1 链接</h3><p>Markdown中提供两个形式的链接方式：行内链接和参考式链接，以行内链接语法做详细说明。</p>
<p>使用<code>[text](link &quot;Optional title&quot;)</code> 表示行内链接，其中：</p>
<ul>
<li><code>[text]</code>：text为需要添加链接的文字；</li>
<li><code>link</code>：link为链接的完整地址；</li>
<li><code>Optional title</code>：为链接显示标题，鼠标放在链接上时会弹出小框表示；</li>
</ul>
<p>例1.行内链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个搜索引擎主页：[Baidu](www.baidu.com &quot;百度一下，你就知道&quot;)</span><br></pre></td></tr></table></figure>

<p>例2.参考式链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个搜索引擎主页：[Baidu][1]</span><br><span class="line">[1]:www.baidu.com &quot;百度一下，你就知道&quot;</span><br></pre></td></tr></table></figure>

<p>Markdown中样式：这是一个搜索引擎主页：<a href="https://www.baidu.com/" title="百度一下，你就知道">Baidu</a></p>
<p>在编辑状态下，行内链接更加直观可以直接看到链接网址，但是不便于多次重复使用。参考式链接可以将链接统一放在文末进行处理，可以重复利用，但对应链接地址稍微麻烦一点。</p>
<h3 id="2-2-URLs"><a href="#2-2-URLs" class="headerlink" title="2.2 URLs"></a>2.2 URLs</h3><p>Markdown语法中使用<code>&lt;&gt;</code>符号表示URLs。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;www.baidu.com&gt;</span><br></pre></td></tr></table></figure>

<p>Markdown中的样式：&lt;<a href="http://www.baidu.com&gt;/">www.baidu.com&gt;</a></p>
<h3 id="2-3-图片"><a href="#2-3-图片" class="headerlink" title="2.3 图片"></a>2.3 图片</h3><p>在Markdown中插入图片类似链接的语法，多了一个<code>!</code></p>
<p><code>![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code>：导入图片，其中：</p>
<ul>
<li><code>Alt text</code>：图片无法显示时显示的问题；</li>
<li><code>/path/to/img.jpg</code>：图片的路径；</li>
<li><code>Optional title</code>：图片的标题，鼠标放在图片上会显示小框提示；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![GitHub](http:<span class="comment">//martintop-image.oss-cn-shenzhen.aliyuncs.com/18-9-19/7391339.jpg &quot;GitHub&quot;)</span></span><br></pre></td></tr></table></figure>

<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-9-19/7391339.jpg" alt="GitHub" title="GitHub"></p>
<ol>
<li>图片路径可以使用绝对路径，也可以使用相对路径。</li>
<li>通常可以在Markdown文档同级目录下建立picture文件夹，统一放置需要的图片，也可以在其中建立子文件夹针对不同图片进行分类管理。</li>
<li>使用Hexo + GitHub搭建博客，为了减少GitHub空间占用，最好使用第三方图床工具进行图片管理。</li>
</ol>
<h3 id="2-4-斜体-amp-加粗"><a href="#2-4-斜体-amp-加粗" class="headerlink" title="2.4 斜体 &amp; 加粗"></a>2.4 斜体 &amp; 加粗</h3><p>使用<code>**</code>或<code>__</code>表示粗体；</p>
<p>使用<code>*</code>或<code>_</code>表示斜体；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**粗体1**    __粗体2__</span><br><span class="line">*斜体1*    _斜体2_</span><br></pre></td></tr></table></figure>

<p><strong>粗体1</strong>    <strong>粗体2</strong><br><em>斜体1</em>    <em>斜体2</em></p>
<ol>
<li>在使用引用<code>&gt;</code>符号时，会忽略<code>_</code>下划线的作用；</li>
<li>推荐使用<code>*</code>或<code>**</code>进行文字强调工作；</li>
<li>如果想要显示<code>*</code>等符号，需要使用转义字符<code>\</code>;</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\* : 在Markdown中显示一个 * </span><br></pre></td></tr></table></figure>

<h3 id="2-5-代码"><a href="#2-5-代码" class="headerlink" title="2.5 代码"></a>2.5 代码</h3><p>使用<code>`</code>符表示行内代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Use `printf()` function.</span><br></pre></td></tr></table></figure>

<p>Use <code>printf()</code> function.</p>
<h3 id="2-6-删除线-amp-下划线"><a href="#2-6-删除线-amp-下划线" class="headerlink" title="2.6 删除线 &amp; 下划线"></a>2.6 删除线 &amp; 下划线</h3><p><code>~~</code>：表示删除线</p>
<p><code>&lt;u&gt;</code>：原生的html标签实现下划线</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~删除文本~~</span><br><span class="line">&lt;u&gt;添加下划线&lt;/u&gt;</span><br></pre></td></tr></table></figure>

<p><del>删除文本</del><br><u>添加下划线</u></p>
<h3 id="2-7-高亮"><a href="#2-7-高亮" class="headerlink" title="2.7 高亮"></a>2.7 高亮</h3><p><code>==</code>：表示高亮文本，属于Markdown的扩展语法，不一定支持，请谨慎使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==高亮文本==</span><br></pre></td></tr></table></figure>

<p>==高亮文本==</p>
<h3 id="2-8-Emoji"><a href="#2-8-Emoji" class="headerlink" title="2.8 Emoji"></a>2.8 Emoji</h3><p>在Markdown中支持丰富的Emoji表情，通常格式为<code>:smile:</code>，冒号中为表情描述。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">:smile: :cry: :rose: :dog: :pig: :mouse: :telephone: :airplane:</span><br></pre></td></tr></table></figure>

<p>:smile: :cry: :rose: :dog: :pig: :mouse: :telephone: :airplane:</p>
<h2 id="3-HTML-amp-高级用法"><a href="#3-HTML-amp-高级用法" class="headerlink" title="3.HTML &amp; 高级用法"></a>3.HTML &amp; 高级用法</h2><p>在Markdown中可以使用html的标签等来实现Markdown本身不支持的一下属性，例如使用下面的语句展示一条红色文本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>this text is red<span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p><span style="color:red">this text is red</span> </p>
<h3 id="3-1-页内跳转"><a href="#3-1-页内跳转" class="headerlink" title="3.1 页内跳转"></a>3.1 页内跳转</h3><p>使用HTML代码实现页内跳转。</p>
<p>在待跳转的位置定义跳转指令：<code>[返回开头](#jumpTop)</code></p>
<p>在要跳转到的目标位置定义锚：<code>&lt;span id = &quot;jumpTop&quot;&gt;hehe&lt;/span&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[返回开头](#jumpTop)</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span> = <span class="string">&quot;jumpTop&quot;</span>&gt;</span>开始<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="#jumpTop">返回开头</a></p>
<h3 id="3-2-视频"><a href="#3-2-视频" class="headerlink" title="3.2 视频"></a>3.2 视频</h3><p>使用<code>&lt;video&gt;</code>HTML的标签来添加视频，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;xxx.mp4&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-其他HTML支持"><a href="#3-3-其他HTML支持" class="headerlink" title="3.3 其他HTML支持"></a>3.3 其他HTML支持</h3><p>其他HTML标签的支持，请参考文档：<a href="https://support.typora.io/HTML/">官方文档</a></p>
<h3 id="3-4-流程图"><a href="#3-4-流程图" class="headerlink" title="3.4 流程图"></a>3.4 流程图</h3><p>流程图目前使用较少，参考文档：<a href="https://support.typora.io/Draw-Diagrams-With-Markdown/">Markdown中绘制流程图</a></p>
<h3 id="3-5-数学公式"><a href="#3-5-数学公式" class="headerlink" title="3.5 数学公式"></a>3.5 数学公式</h3><p>数学公式目前使用较少，参考文档：<a href="https://support.typora.io/Math/">Markdown中数学公式</a></p>
<h1 id="Typora工具"><a href="#Typora工具" class="headerlink" title="Typora工具"></a>Typora工具</h1><h2 id="1-Typora工具介绍"><a href="#1-Typora工具介绍" class="headerlink" title="1. Typora工具介绍"></a>1. Typora工具介绍</h2><p><span id = "jumpTypora">Typora是一款轻便简洁的Markdown编辑器</span>，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。</p>
<ul>
<li><p>在Typora工具中，使用列表时可以通过Tab功能键增加子列表节点。</p>
</li>
<li><p>在Typora工具中，URLs会自动链接到目标网址。</p>
</li>
<li><p>在Typora工具中，可以图形化的创建、使用表格工具。</p>
</li>
</ul>
<p>还有更换主题、Emoji自动带出、支持YAML Front Matter等等特性。</p>
<h2 id="2-Typora常用快捷键"><a href="#2-Typora常用快捷键" class="headerlink" title="2. Typora常用快捷键"></a>2. Typora常用快捷键</h2><h3 id="2-1-块元素操作"><a href="#2-1-块元素操作" class="headerlink" title="2.1 块元素操作"></a>2.1 块元素操作</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+1~6</td>
<td>1~6阶标题</td>
<td>Ctrl+Shift+Q</td>
<td>引用</td>
</tr>
<tr>
<td>Ctrl+Shift+[</td>
<td>有序列表</td>
<td>Ctrl+Shift+]</td>
<td>无序列表</td>
</tr>
<tr>
<td>Ctrl+Shift+K</td>
<td>代码块</td>
<td>Ctrl+Shift+M</td>
<td>公式块</td>
</tr>
<tr>
<td>Ctrl+T</td>
<td>创建表格</td>
<td>Ctrl+Shift+Q</td>
<td>引用</td>
</tr>
</tbody></table>
<p>以上列大部分还没有直接使用Markdown语法来的方便，除了生成表格外：<code>Ctrl+T</code></p>
<h3 id="2-2-行内元素操作"><a href="#2-2-行内元素操作" class="headerlink" title="2.2 行内元素操作"></a>2.2 行内元素操作</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+K</td>
<td>创建超链接</td>
<td>Ctrl+Shift+I</td>
<td>插入图片</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>字体加粗</td>
<td>Ctrl+I</td>
<td>字体倾斜</td>
</tr>
<tr>
<td>Ctrl+U</td>
<td>下划线</td>
<td>Alt+Shift+5</td>
<td>删除线</td>
</tr>
</tbody></table>
<p>以上即为学习Markdown并结合Typora工具的总结，可以满足绝大部分的使用需要了。</p>
<blockquote>
<p>本文参考文章</p>
<p><a href="https://support.typora.io/Markdown-Reference/#span-elements">Markdown Reference(Typora官方文档)</a></p>
<p><a href="http://www.cnblogs.com/crazyant007/p/4220066.html#fnref1">Markdown，你只需要掌握这几个</a></p>
<p><a href="https://blog.csdn.net/qq_41648756/article/details/81057290#%E7%BC%96%E8%BE%91%E5%99%A8typora">编辑器：Typora</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>jmap命令配合MAT工具分析java内存泄露情况</title>
    <url>/2018/12/07/jmap%E5%91%BD%E4%BB%A4%E9%85%8D%E5%90%88MAT%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90java%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p>今天测试同学压测的时候又反馈内存有0.4%个百分点的上浮，其实之前用top命令观察了一段时间没什么问题。如果存在内存泄露的问题内存使用率应该会持续增加，而不是压了一个晚上也可以保持稳定。 :sweat: 不过两台服务器上一个项目的进程内存占用的确有一点点差别，保险起见dump堆转储文件分析看看，也学习一下。</p>
<span id="more"></span>

<h2 id="一-内存监控检视"><a href="#一-内存监控检视" class="headerlink" title="一. 内存监控检视"></a>一. 内存监控检视</h2><p>目前系统在测试环境压测时内存检测如下图，这种比较稳定的一般不存在内存泄露的问题：</p>
<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-12-7/93522148.jpg" alt="uws"></p>
<p>典型的可能存在内存泄露的监控图如下：</p>
<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-12-7/223989.jpg" alt="内存泄漏"></p>
<h2 id="二、jmap命令"><a href="#二、jmap命令" class="headerlink" title="二、jmap命令"></a>二、jmap命令</h2><p>jmap命令是jdk自带的小工具，可以打印分析java进程的共享对象内存映射、堆内存的细节等。</p>
<p>jmap命令可以获得运行中的jvm的堆的快照，从而可以：</p>
<ul>
<li>离线分析堆，以检查内存泄漏，检查一些严重影响性能的大对象的创建；</li>
<li>检查系统中什么对象最多，各种对象所占内存的大小等等；</li>
<li>可以使用jmap生成Heap Dump文件后抓取到本地进一步分析。</li>
</ul>
<blockquote>
<p><strong>什么是堆Dump</strong></p>
<p>堆Dump是反应Java堆使用情况的内存镜像，其中主要包括系统信息、虚拟机属性、完整的线程Dump、所有类和对象的状态等。 一般，在内存不足、GC异常等情况下，我们就会怀疑有内存泄露。这个时候我们就可以制作堆Dump来查看具体情况。</p>
</blockquote>
<h3 id="1-命令概述"><a href="#1-命令概述" class="headerlink" title="1.命令概述"></a>1.命令概述</h3><p>在shell中输入jmap有很完整的命令介绍：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[app@VM_101_178_centos irps-uws]$ jmap</span><br><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    #打印jvm的heap情况</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    #打印jvm的heap直方图：类型、对象数量、占用大小等，:live-可选是打印存活对象</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to print class loader statistics</span><br><span class="line">    #显示在 F-Queue 队列等待 Finalizer 线程执行 finalize 方法的对象 </span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    #输出jvm堆内存信息到文件</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format	#dump命令可选参数，以二进制输出</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt; #命名输出文件</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure>

<h3 id="2-详细说明"><a href="#2-详细说明" class="headerlink" title="2.详细说明"></a>2.详细说明</h3><h4 id="2-1-jmap-heap-pid"><a href="#2-1-jmap-heap-pid" class="headerlink" title="2.1 jmap -heap pid"></a>2.1 jmap -heap pid</h4><p>打印pid的整体堆栈信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">一般先使用top命令查看内存占用情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash">然后按大写字母M，以mem占用排序pid，再使用jmp进一步分析</span></span><br><span class="line">[app@VM_101_178_centos irps-uws]$ jmap -heap 65067</span><br><span class="line">Attaching to process ID 65067, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.152-b16</span><br><span class="line"></span><br><span class="line">using parallel threads in the new generation.#新生代采用的是并行线程处理方式</span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Concurrent Mark-Sweep GC#同步并行垃圾回收方式</span><br><span class="line"></span><br><span class="line">Heap Configuration:#堆配置情况</span><br><span class="line">   MinHeapFreeRatio         = 40 #最小堆使用比例</span><br><span class="line">   MaxHeapFreeRatio         = 70 #最大堆使用比例</span><br><span class="line">   MaxHeapSize              = 2147483648 (2048.0MB) #最大堆空间大小</span><br><span class="line">   NewSize                  = 805306368 (768.0MB)	#新生代分配大小</span><br><span class="line">   MaxNewSize               = 805306368 (768.0MB)	#最大可新生代分配大小</span><br><span class="line">   OldSize                  = 1342177280 (1280.0MB)	#老生代大小</span><br><span class="line">   NewRatio                 = 2	#新生代比例</span><br><span class="line">   SurvivorRatio            = 8	#新生代与suvivor的比例</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 134217728 (128.0MB)</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:#堆使用情况</span><br><span class="line">New Generation (Eden + 1 Survivor Space):#新生代（伊甸区 + survior空间）</span><br><span class="line">   capacity = 724828160 (691.25MB)</span><br><span class="line">   used     = 283548752 (270.4131622314453MB)</span><br><span class="line">   free     = 441279408 (420.8368377685547MB)</span><br><span class="line">   39.11944480744236% used</span><br><span class="line">Eden Space:#伊甸区</span><br><span class="line">   capacity = 644349952 (614.5MB)</span><br><span class="line">   used     = 283111232 (269.99591064453125MB)</span><br><span class="line">   free     = 361238720 (344.50408935546875MB)</span><br><span class="line">   43.937495629704024% used</span><br><span class="line">From Space:#survior1区</span><br><span class="line">   capacity = 80478208 (76.75MB)</span><br><span class="line">   used     = 437520 (0.4172515869140625MB)</span><br><span class="line">   free     = 80040688 (76.33274841308594MB)</span><br><span class="line">   0.5436502761095277% used</span><br><span class="line">To Space:#survior2 区</span><br><span class="line">   capacity = 80478208 (76.75MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 80478208 (76.75MB)</span><br><span class="line">   0.0% used</span><br><span class="line">concurrent mark-sweep generation:#老生代使用情况</span><br><span class="line">   capacity = 1342177280 (1280.0MB)</span><br><span class="line">   used     = 97188168 (92.68585968017578MB)</span><br><span class="line">   free     = 1244989112 (1187.3141403198242MB)</span><br><span class="line">   7.241082787513733% used</span><br><span class="line"></span><br><span class="line">33675 interned Strings occupying 4006736 bytes.</span><br></pre></td></tr></table></figure>

<h4 id="2-2-jmap-finalizerinfo-pid"><a href="#2-2-jmap-finalizerinfo-pid" class="headerlink" title="2.2 jmap -finalizerinfo pid"></a>2.2 jmap -finalizerinfo pid</h4><p>打印等候回收的对象的信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[app@VM_101_178_centos irps-uws]$ jmap -finalizerinfo 65067</span><br><span class="line">Attaching to process ID 65067, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.152-b16</span><br><span class="line">Number of objects pending for finalization: 0	#0个对象在等候被回收</span><br></pre></td></tr></table></figure>

<h4 id="2-3-jmap-histo-pid"><a href="#2-3-jmap-histo-pid" class="headerlink" title="2.3 jmap -histo pid"></a>2.3 jmap -histo pid</h4><p>打印每个class的实例数目,内存占用,类全名信息. VM的内部类名字开头会加上前缀<code>*</code>. 如果live子参数加上后,只统计活的对象数量. </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">-histo命令会打印大量实例，最好和less配合使用</span></span><br><span class="line"> [app@VM_101_178_centos irps-uws]$ jmap -histo 65067|less</span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:       1915748      208902184  [C</span><br><span class="line">   2:        729935       86852936  [B</span><br><span class="line">   3:        491930       51925552  [Ljava.lang.Object;</span><br><span class="line">   4:        670703       32193744  java.util.HashMap</span><br><span class="line">   5:        349710       30774480  java.lang.reflect.Method</span><br><span class="line">   6:        139541       20728016  [I</span><br><span class="line">   7:        242339       20377456  [Ljava.util.HashMap$Node;</span><br><span class="line">   8:        800805       19219320  java.lang.String</span><br><span class="line">   9:        551565       17650080  java.util.HashMap$Node</span><br><span class="line">  10:        931898       16330024  [Ljava.lang.Class;</span><br><span class="line">  11:        348377       13935080  java.util.HashMap$KeyIterator</span><br><span class="line">  12:        175761       12654792  java.lang.reflect.Field</span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash">instance 是对象的实例个数</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">bytes 是总占用的字节数</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">class name 对应的就是 Class 文件里的 class 的标识</span> </span><br><span class="line">B 代表 byte</span><br><span class="line">C 代表 char</span><br><span class="line">D 代表 double</span><br><span class="line">F 代表 float</span><br><span class="line">I 代表 int</span><br><span class="line">J 代表 long</span><br><span class="line">Z 代表 boolean</span><br><span class="line">前边有 [ 代表数组， [I 就相当于 int[]</span><br><span class="line">对象用 [L + 类名表示</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">补充常用指令配合使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash">输出到a.log文件中，可以隔段时间输出并对比观察gc回收的情况</span></span><br><span class="line">jmap -histo:live pid&gt;a.log </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">只统计存活对象情况，ps：这个命令执行，JVM会先触发gc，然后再统计信息。</span></span><br><span class="line">jmap -histo:live pid </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看对象数最多的对象，并按降序排序输出：</span></span><br><span class="line">jmap -histo &lt;pid&gt;|grep alibaba|sort -k 2 -g -r|less #alibaba为需要搜索的对象</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看占用内存最多的最象，并按降序排序输出：</span></span><br><span class="line">jmap -histo &lt;pid&gt;|grep alibaba|sort -k 3 -g -r|less</span><br></pre></td></tr></table></figure>

<h4 id="2-4-jmap-dump-live-format-b-file-filename-pid"><a href="#2-4-jmap-dump-live-format-b-file-filename-pid" class="headerlink" title="2.4 jmap -dump:live,format=b,file=filename pid"></a>2.4 jmap -dump:live,format=b,file=filename pid</h4><p>jmap -dump命令用于生成堆转储文件，其中的live、format指令均可选。一般生成MAT分析的文件以<code>.hprof</code>的后缀结尾。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">输出堆转储文件到dumpfile.hprof</span></span><br><span class="line">[app@VM_101_178_centos irps-uws]$ jmap -dump:live,format=b,file=dumpfile.hprof 65067</span><br><span class="line">Dumping heap to /data/appsystems/irps-uws/dumpfile.hprof ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个命令执行，JVM会将整个heap的信息dump写入到一个文件，heap如果比较大的话，就会导致这个过程比较耗时，并且执行的过程中为了保证dump的信息是可靠的，所以会暂停应用。</p>
</blockquote>
<h2 id="三、利用MAT检查内存泄露"><a href="#三、利用MAT检查内存泄露" class="headerlink" title="三、利用MAT检查内存泄露"></a>三、利用MAT检查内存泄露</h2><p>dump了文件到服务器上，使用scp或sz命令从Linux环境下载到本地环境。</p>
<h3 id="1-MAT下载安装"><a href="#1-MAT下载安装" class="headerlink" title="1.MAT下载安装"></a>1.MAT下载安装</h3><ul>
<li><p>将MAT当做eclipse的插件进行安装：启动Eclipse –&gt; Help –&gt; Eclipse Marketplace，然后搜索Memory Analyzer，安装，重启eclipse即可。</p>
</li>
<li><p>将MAT作为一个独立的软件进行安装：去官网<a href="http://www.eclipse.org/mat/downloads.php">http://www.eclipse.org/mat/downloads.php</a>，根据操作系统版本下载最新的MAT。下载后解压就可以运行了。</p>
</li>
</ul>
<p>推荐第二种方式哈 :cocktail:</p>
<h3 id="2-MAT配置"><a href="#2-MAT配置" class="headerlink" title="2.MAT配置"></a>2.MAT配置</h3><p>MAT 软件版本解压后目录内有个MemoryAnalyzer.ini文件，该文件里面有个Xmx参数，该参数表示最大内存占用量，默认为1024m，根据堆转储文件大小修改该参数即可。</p>
<ul>
<li>MemoryAnalyzer.ini中的参数一般默认为-vmargs– Xmx1024m，这就够用了。假如你机器的内存不大，改大该参数的值，会导致MemoryAnalyzer启动时，报错:Failed to create the Java Virtual Machine。</li>
<li>当你导出的dump文件的大小大于你配置的1024m（说明1中，提到的配置：-vmargs– Xmx1024m），MAT输出分析报告的时候，会报错：An internal error occurred during: “Parsing heap dump from XXX”。适当调大说明1中的参数即可。</li>
</ul>
<h3 id="3-使用MAT分析堆转储文件"><a href="#3-使用MAT分析堆转储文件" class="headerlink" title="3.使用MAT分析堆转储文件"></a>3.使用MAT分析堆转储文件</h3><p>打开mat后，选择File -&gt; Open Heap Dump找到下载到本地的dump文件打开。</p>
<ul>
<li>加载后首页如下，主要关注Leak Suspects功能-泄露分析。</li>
</ul>
<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-12-7/53428060.jpg" alt="MAT首页"></p>
<ul>
<li>点击Leak Suspects，.hprof文件所在文件夹 :file_folder: 会生成一个压缩包。如果需要和同事一起分析这个内存问题，只需要把这个小小的 zip 包发给他就可以了，不需要把整个堆文件发给他。并且整个报告是一个 HTML 格式的文件，用浏览器就可以打开。</li>
</ul>
<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-12-7/58536573.jpg" alt="MAT ZIP"></p>
<ul>
<li>进入suspects页面如下，MAT工具会列出来可能存在内存泄露的位置。现在看唯一的可能泄露是jar包中的并不是程序代码导致，所以程序不存在内存泄露的问题。</li>
</ul>
<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-12-7/37832446.jpg" alt="Leak Suspects"></p>
<ul>
<li>假如存在内存泄露我们可以点击Details进一步分析，参考网上的blog如下。这个截图其实就说明是系统代码的问题了。</li>
</ul>
<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-12-7/40088292.jpg" alt="suspect"></p>
<ul>
<li>在详情页面<strong>Shortest Paths To the Accumulation Point</strong>表示GC root到内存消耗聚集点的最短路径，如果某个内存消耗聚集点有路径到达GC root，则该内存消耗聚集点不会被当做垃圾被回收。（所以重点关注哦）</li>
</ul>
<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-12-7/76005603.jpg" alt="内存泄露~"></p>
<ul>
<li><p>在All Accumulated Objects by Class列举了该对象所存储的所有内容。其实从这个地方已经可以大概分析出问题了，EventInfo这个对象数量不太正常。</p>
<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-12-7/81909733.jpg" alt="EventInfo"></p>
</li>
<li><p>为了更精确的定位，可以抓取间隔一段时间的两个dump文件进行对比分析，更加容易定位内存泄露的位置。</p>
</li>
</ul>
<blockquote>
<p>MAT同时打开两个堆转储文件，分别打开Histogram，如下图。在下图中方框1按钮用于对比两个Histogram，对比后在方框2处选择Group By package，然后对比各对象的变化。不难发现heap3.hprof比heap6.hprof少了64个eventInfo对象</p>
</blockquote>
<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-12-7/29004956.jpg" alt="compare dump file"></p>
<ul>
<li>最终分析结果如下：</li>
</ul>
<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-12-7/97387390.jpg" alt="result"></p>
<blockquote>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/wanghuiqi2008/article/details/50724676">使用 Eclipse Memory Analyzer 进行堆转储文件分析</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/index.html">利用内存分析工具（Memory Analyzer Tool，MAT）分析java项目内存泄露</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux Learning</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm性能调优&amp;监控-jps jstat jstack jmap jinfo</title>
    <url>/2018/12/11/jvm%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98&amp;%E7%9B%91%E6%8E%A7-jps%20jstat%20jstack%20jmap%20jinfo/</url>
    <content><![CDATA[<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-12-11/28660764.jpg"></p>
<p>上一份工作其实几乎不怎么接触这些，生产环境的权限控制严格，大部分是由运维来做的。这段时间看了一些jvm性能调优、内存异常监控排查的blog，大部分也是东抄西抄，是时候系统的小结一波，大概归纳下jdk自带的常用命令，本文只简单介绍各个命令基本语法和最常用的功能，详细内容再单独开篇学习吧。</p>
<p>ps：除了标题列举的命令之外其实还有jhat、jconsole等命令，只不过jhat对比mat工具实在不够直观，jconsole图形化界面在服务器上也不一定能用。</p>
<span id="more"></span>

<h2 id="1-jps"><a href="#1-jps" class="headerlink" title="1.jps"></a>1.jps</h2><p>jps=JVM Process Status Tool，用于显示当前系统(未指定hostid时)内HotSpot虚拟机中的进程情况。常用命令：</p>
<ul>
<li><p>jps -m：输出传递给main方法的参数。</p>
</li>
<li><p>jps -v：输出传递给JVM的参数。举例如下：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[app@VM_104_20_centos irps-chs]$ jps -m</span><br><span class="line">216635 JMap -histo 125676</span><br><span class="line">81530 JMap -dump:format=b,file=/tmp/irps-chs.hprof</span><br><span class="line">215688 Jps -m</span><br><span class="line">216765 JConsole</span><br><span class="line">[app@VM_104_20_centos irps-chs]$ jps -v</span><br><span class="line">215744 Jps -Dapplication.home=/nemo/jdk1.8.0_152 -Xms8m</span><br><span class="line">216635 JMap -Dapplication.home=/nemo/jdk1.8.0_152 -Xms8m -Dsun.jvm.hotspot.debugger.useProcDebugger -Dsun.jvm.hotspot.debugger.useWindbgDebugger</span><br><span class="line">81530 JMap -Dapplication.home=/nemo/jdk1.8.0_152 -Xms8m -Dsun.jvm.hotspot.debugger.useProcDebugger -Dsun.jvm.hotspot.debugger.useWindbgDebugger</span><br></pre></td></tr></table></figure>

<p>Oracle官方文档：<a href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html">jps说明</a></p>
<h2 id="2-jstat"><a href="#2-jstat" class="headerlink" title="2.jstat"></a>2.jstat</h2><p>jstat=JVM statistics Monitoring，用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。注意使用时需要加上进程id、所选参数。</p>
<p>语法结构为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]</span><br><span class="line"><span class="meta">#</span><span class="bash">option:可选操作参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash">LVMID：本地虚拟机进程ID</span></span><br><span class="line"><span class="meta">#</span><span class="bash">interval：输出间隔，默认单位ms</span></span><br><span class="line"><span class="meta">#</span><span class="bash">count：输出次数</span></span><br></pre></td></tr></table></figure>

<p>常用命令：</p>
<ul>
<li>jstat -class LVMID：监视类装载数量、消耗空间，时间等。</li>
<li>jstat -compiler LVMID：输入JIT编译的方法数量、失败数量、耗时、编译失败类型及方法等。</li>
<li>jstat -gcutil LVMID interval count：统计程序gc情况(已用空间占总空间百分比)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[app@VM_104_20_centos irps-chs]$ jstat -class 125676</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line"> 11825 22520.2        0     0.0    2509.31</span><br><span class="line"> </span><br><span class="line">[app@VM_104_20_centos irps-chs]$ jstat -compiler 125676</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">   14442      4       0   103.53          1 com/alibaba/druid/filter/FilterChainImpl connection_prepareStatement</span><br><span class="line">   </span><br><span class="line">[app@VM_104_20_centos irps-chs]$ jstat -gcutil 125676 3000 2 #每3s输出，一共输出两次</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  0.37   0.00   7.33  45.04  98.17  96.25  11884  110.109     4    0.382  110.492</span><br><span class="line">  0.37   0.00   7.33  45.04  98.17  96.25  11884  110.109     4    0.382  110.492</span><br></pre></td></tr></table></figure>

<p>Oracle官方文档：<a href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html">jstat说明</a></p>
<h2 id="3-jstack"><a href="#3-jstack" class="headerlink" title="3.jstack"></a>3.jstack</h2><p>jstack用于生成java虚拟机当前时刻的线程快照，即当前java虚拟机内<strong>所有线程</strong>正在执行的方法堆栈的集合。</p>
<p>所以jstack可以用于观察jvm中当前所有线程的运行情况和线程当前状态，定位线程出现长时间停顿的原因，如<strong>线程间死锁、死循环、请求外部资源导致的长时间等待</strong>等。 </p>
<blockquote>
<p>系统崩溃了？如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。</p>
<p>系统hung住了？jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态。</p>
</blockquote>
<p>语法格式及说明：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstack [option] LVMID</span><br><span class="line"><span class="meta">#</span><span class="bash">option可选参数有：</span></span><br><span class="line">-F : 当正常输出请求不被响应时，强制输出线程堆栈</span><br><span class="line">-l : 除堆栈外，显示关于锁的附加信息</span><br><span class="line">-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</span><br></pre></td></tr></table></figure>

<p>Oracle官方文档：<a href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html">jstack说明</a></p>
<h2 id="4-jmap"><a href="#4-jmap" class="headerlink" title="4.jmap"></a>4.jmap</h2><p>jmap=JVM Memory Map，用于生成dump文件、查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p>
<p>语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap [option] LVMID</span><br><span class="line"><span class="meta">#</span><span class="bash">option参数：</span></span><br><span class="line">-dump : 生成堆转储快照</span><br><span class="line">-finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">-heap : 显示Java堆详细信息</span><br><span class="line">-histo : 显示堆中对象的统计信息</span><br><span class="line">-permstat : to print permanent generation statistics</span><br><span class="line">-F : 当-dump没有响应时，强制生成dump快照</span><br></pre></td></tr></table></figure>

<p>Oracle官方文档：<a href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html">jmap说明</a></p>
<h2 id="5-jinfo"><a href="#5-jinfo" class="headerlink" title="5.jinfo"></a>5.jinfo</h2><p>jinfo=Java Configuration Info，相比于其他命令jinfo用法比较简单，主要用于实时查看或调整当前JVM配置的系统属性。常用命令如下：</p>
<ul>
<li>jinfo pid：打印指定process id的系统属性、jvm配置</li>
<li>jinfo -flag [MaxHeapSize] pid：查看pid具体的参数值。举例如下：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[app@VM_104_20_centos irps-chs]$ jinfo 62316</span><br><span class="line">Attaching to process ID 62316, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line"><span class="meta">#</span><span class="bash">先展示系统相关属性</span></span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.152-b16</span><br><span class="line">Java System Properties:</span><br><span class="line"></span><br><span class="line">java.vendor = Oracle Corporation</span><br><span class="line">sun.java.launcher = SUN_STANDARD</span><br><span class="line">catalina.base = /irps-chs</span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash">然后是jvm相关参数</span></span><br><span class="line">VM Flags:</span><br><span class="line">Non-default VM flags: -XX:+AlwaysPreTouch -XX:AutoBoxCacheMax=20000 -XX:CICompilerCount=3 -XX:CMSInitiatingOccupancyFraction=75 -XX:ErrorFile=null -XX:+ExplicitGCInvokesConcurrent</span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash">指定查看MaxHeapSize大小</span></span><br><span class="line">[app@VM_104_20_centos irps-chs]$ jinfo -flag MaxHeapSize  62316</span><br><span class="line">-XX:MaxHeapSize=2147483648</span><br></pre></td></tr></table></figure>

<blockquote>
<p>jinfo命令也可以实时配置一些jvm参数，使用的不太多，具体可参考：</p>
<p><a href="https://www.jianshu.com/p/c321d0808a1b">jinfo调整jvm参数</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux Learning</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读JDK源码</title>
    <url>/2019/04/17/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BBJDK%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>从去年年中跳槽几次面试就已经意识到了阅读JDK源码的重要性。从最基础的List，Map衍生开去，各种数据结构的相关特性，是否线程安全？如何进行扩容？不同业务场景下选用何种数据类型？以及有的面试官会问String类型的哈希值，以及计算原理。。。(略坑)。不仅仅是JDK源码，学习Spring、Netty、Dubbo的源码对于个人提升都有好处。对于我来说克服畏难情绪固然重要，好的方法也是可以坚持下去的重要因素。</p>
<span id="more"></span>

<h2 id="How-to"><a href="#How-to" class="headerlink" title="How to"></a>How to</h2><p>开始前的准备工作~</p>
<h3 id="搜索网上资料"><a href="#搜索网上资料" class="headerlink" title="搜索网上资料"></a>搜索网上资料</h3><p>阅读一个框架的源码，最基础的操作肯定是扫一遍网上的各种分析文章。通过这个操作，你可以对这个框架有个大致的了解。站在巨人的肩膀上，少走许多弯路。但如果你看的项目是公司内部的框架，那么你只能找公司内部的文档了，更甚者，有些连文档都没有。那么你可以略过这一步。</p>
<h3 id="扫一遍源码"><a href="#扫一遍源码" class="headerlink" title="扫一遍源码"></a>扫一遍源码</h3><p>当你拿到框架的源码的时候，你可以大致把源码的每个包，以及每个包下面的文件扫读一遍。扫读并不需要你弄清楚每一行代码的意思，只需要让你知道源码每一部分的作用。</p>
<p>如果一个开源框架足够标准，那么他的命名是非常语义化的。所以我们扫读的时候，通过包名、文件名就可以判断出这个包是用来干嘛的。例如 util 包是工具类，那我们可以直接跳过。vo 包是存放实体模型的，同样可以跳过。protocol 包是存放协议相关的等等。通过这么一个步骤，你会对整个项目有一个基本的印象，知道这个项目大概有哪些东西，哪些相对比较重要。</p>
<h3 id="找到入口"><a href="#找到入口" class="headerlink" title="找到入口"></a>找到入口</h3><p>阅读任何一个框架的源码，首先就是要找到框架的入口。通过上面扫读源码，你应该能够发现一些入口的迹象，例如对于 Dubbo 来说，你会发现它有一个名为 dubbo-demo 的子模块，那么我们肯定重点看它。进一步发掘需求你会发现它的入口就是 dubbo-demo 中的 Provider 类、Consumer 类。我们可以直接接运行这两个类的 main 方法，并一步步跟踪代码的执行情况。</p>
<h3 id="通读源码"><a href="#通读源码" class="headerlink" title="通读源码"></a>通读源码</h3><p>找到入口之后，下一步就是通读所有源码了，就是把源码的每个文件每一行都看一遍。在这个阶段不求完全弄懂细致的业务逻辑，但是要形成一个大概的框架，知道这个框架是如何设计的，有哪些大致的模块，这些模块是如何设计的。</p>
<blockquote>
<p>在通读源码的过程中最容易出现倦怠的情绪，通过系统给的统计和记录我觉得是一个比较有作用的方法。</p>
<p>利用idea代码统计插件-Statistics，对需要阅读的代码进行整理统计，使用EXCEL进行记录。</p>
</blockquote>
<p> <img src="https://martintop-image.oss-cn-shenzhen.aliyuncs.com/19-4-24/20190424180707.png" alt="统计"></p>
<p> <img src="https://martintop-image.oss-cn-shenzhen.aliyuncs.com/19-4-24/20190424180729.png" alt="总计"></p>
<h3 id="梳理框架"><a href="#梳理框架" class="headerlink" title="梳理框架"></a>梳理框架</h3><p>在通读源码的过程中，你就会对框架有许多新的认识，会知道这个框架大致分为哪几个部分，每个部分的作用是什么，这个模块用了什么设计理念等等。</p>
<p>如果说上个阶段是通读源码，那么这个阶段就是要把你在通读源码过程中的收获整理出来。在整理的过程中，你肯定会有更多的疑问，你会不断地细化，不断地精读。</p>
<h3 id="批判性思考"><a href="#批判性思考" class="headerlink" title="批判性思考"></a>批判性思考</h3><p>通过了上面几个阶段，你会发现你对这个框架有了整体的认识，并且对每个模块的实现细节都有了比较深刻的认识。这个时候，你可以想一想为什么它要这么做，这么做有什么好处，那能用另一种方式做得更好吗？</p>
<h2 id="What-to"><a href="#What-to" class="headerlink" title="What to"></a>What to</h2><h3 id="JDK部分"><a href="#JDK部分" class="headerlink" title="JDK部分"></a>JDK部分</h3><p>JDK其实就是Java SE Development Kit的缩写，要玩好这东西可不简单。JDK主要包含了三部分，第一部分就是 Java运行时环境 ，这其实就是JVM。此外，第二部分就是 Java的基础类库 ，这个类库的数量还是非常可观的。最后，第三部分就是 Java的开发工具 ，它们都是辅助你更好的使用Java的利器。</p>
<p>那么很显然，要玩好JDK，就是要玩好JDK的这三部分。接下来，咱们就逐个的来说一下，每一个部分要学什么，学到什么程度。</p>
<h4 id="第一部分：Java运行时环境"><a href="#第一部分：Java运行时环境" class="headerlink" title="第一部分：Java运行时环境"></a>第一部分：Java运行时环境</h4><p>这一部分其实就是常说的jre，而它的核心其实就一个东西，就是JVM。</p>
<p>JVM这个东西，它的重要性LZ不想再强调了，JVM那本书甚至比《Thinking in java》还重要，这已经足见LZ多么看重JVM了。</p>
<p>当然了，只是LZ看重，当然没什么卵用，但只要Java稍微高级一点点的职位，这部分基本上都是面试必问内容，这更加说明了JVM的重要性。</p>
<h4 id="第二部分：Java的基础类库"><a href="#第二部分：Java的基础类库" class="headerlink" title="第二部分：Java的基础类库"></a>第二部分：Java的基础类库</h4><ol>
<li><p><strong>精读源码</strong></p>
<ul>
<li><p>java.io</p>
</li>
<li><p>java.lang</p>
</li>
<li><p>java.uti</p>
</li>
</ul>
</li>
<li><p><strong>深刻理解</strong></p>
<ul>
<li>java.lang.reflect</li>
<li>java.netjavax.net.</li>
<li>java.nio.</li>
<li>java.util.concurrent.*</li>
</ul>
</li>
<li><p><strong>会用即可</strong></p>
</li>
</ol>
<p>  java.lang.annotation<br>  javax.annotation.*<br>  java.lang.refjava.mathjava.rmi.*<br>  javax.rmi.*<br>  java.security.*<br>  javax.security.*<br>  java.sqljavax.sql.*<br>  javax.transaction.*<br>  java.textjavax.xml.*<br>  org.w3c.dom.*<br>  org.xml.sax.*<br>  javax.crypto.*<br>  javax.imageio.*<br>  javax.jws.*<br>  java.util.*</p>
<p>  剩下的诸如swing、awt稍微了解一下即可，已经很少使用了。更加详细的顺序可以参考这篇博客的内容： <a href="https://blog.csdn.net/qq_21033663/article/details/79571506">JDK源码阅读顺序</a></p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><a href="https://www.zhihu.com/question/61539640">有哪些值得一读的Java源码-知乎问答</a></p>
<p><a href="https://www.cnblogs.com/chanshuyi/p/take_about_my_java_tech_system.html#%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81">聊聊我的知识体系</a></p>
<p>参考文章：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3ODg3OTk4OA==&mid=2651087534&idx=1&sn=93f5bd700af1de2f193062b2fd991994&chksm=844ccf35b33b46231892b82bf6aa86b5fb89120a319fec1602a6e74cabff9d5c8e3b9b4e2436&mpshare=1&scene=23&srcid=0430tGrNDhqZlXzixAqH8xxp#rd">扎实的java基础</a></p>
<p><a href="https://www.cnblogs.com/chanshuyi/p/how_to_read_source_code.html">面对枯燥的源码如何阅读下去</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2018/11/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="http://martintop-image.oss-cn-shenzhen.aliyuncs.com/18-11-20/7400407.jpg" alt="某一天的公司看去"></p>
<p>Q：正则表达式是什么？</p>
<p>A：在编写处理字符串，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具，也即记录文本规则的代码。例如：匹配符合规则的邮箱地址、手机号码等等。</p>
<span id="more"></span>

<h2 id="1-从例子开始"><a href="#1-从例子开始" class="headerlink" title="1.从例子开始"></a>1.从例子开始</h2><p>假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。但是很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用<code>\bhi\b</code></p>
<ul>
<li><code>\b</code> 是正则表达式规定的一个特殊代码（元字符）,代表着单词的开头或结尾，也就是单词的分界处。通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些分隔字符，它<strong>只匹配一个位置</strong>。</li>
</ul>
<p>假如你要找的是hi后面不远处跟着一个Lucy，应该用<code>\bhi\b.*\bLucy\b</code></p>
<ul>
<li><code>.</code>是另一个元字符，匹配除了换行符以外的任意字符。</li>
<li><code>*</code>也是元字符，它代表数量：*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。</li>
</ul>
<p>所以两者结合使用 **.***：代表任意数量的不包含换行的字符。</p>
<p><strong><code>^[0-9]+abc$</code></strong></p>
<ul>
<li>^ 为匹配输入字符串的开始位置。</li>
<li>[0-9]+匹配多个数字， [0-9] 匹配单个数字，+ 匹配一个或者多个。</li>
<li>abc$匹配字母 abc 并以 abc 结尾，$ 为匹配输入字符串的结束位置。</li>
<li>可以匹配<strong>1232xyzabc、32eabc</strong>等。</li>
</ul>
<p><strong><code>^[a-z0-9_-]&#123;3,15&#125;$</code></strong></p>
<ul>
<li>^ 为匹配输入字符串的开始位置。</li>
<li>[a-z0-9_-]匹配字母a-z、数字0-9、下划线、连字符。</li>
<li>{3,15}匹配3-15个字符长度</li>
<li>$结束标记</li>
<li>可以匹配 <strong>runoob、runoob1、run-oob、run_oob</strong>， 但不匹配 <strong>ru</strong>，因为它包含了小写的字母而且太短了，也不匹配 <strong>runoob$</strong>, 因为它包含特殊字符。</li>
</ul>
<h2 id="2-正则表达式的语法"><a href="#2-正则表达式的语法" class="headerlink" title="2.正则表达式的语法"></a>2.正则表达式的语法</h2><h3 id="2-1普通字符"><a href="#2-1普通字符" class="headerlink" title="2.1普通字符"></a>2.1普通字符</h3><p>普通字符也就是一般的字符类，包括没有显式指定为元字符的所有可打印和不可打印字符。这包括<strong>所有大写和小写字母、所有数字、所有标点符号和一些其他符号</strong> .举例如下：</p>
<ul>
<li>[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</li>
<li>[0-9]代表的含意与\d就是完全一致的：一位数字；(用来指定范围)</li>
<li><code>\(?0\d&#123;2&#125;[) -]?\d&#123;8&#125;</code>：这个复杂的表达式由几个部分组成，<code>\(</code>一个转义字符，可以出现<code>?</code>零次或一次；然后是一个数字<code>0</code>,后面跟着两个数字<code>\d&#123;2&#125;</code>;接下来是一个方括号表达式<code>[) -]?</code>表示括号、空格或连接符中的任何一个，出现零次或一次；最后为八个数字<code>\d&#123;8&#125;</code>。从以上分析可知，该正则表达式可以匹配：(010)88886666，或022-22334455，或02912345678等</li>
</ul>
<h3 id="2-2常用元字符"><a href="#2-2常用元字符" class="headerlink" title="2.2常用元字符"></a>2.2常用元字符</h3><p>非打印字符也可以是正则表达式的组成部分。如下表所示：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>.</strong></td>
<td>匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 <code>\.</code> 。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配<strong>字母、数字、下划线</strong>。等价于’[A-Za-z0-9_]’。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个<strong>数字</strong>字符。等价于 [0-9]。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何<strong>空白字符</strong>，包括空格、制表符、换页符等等 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个<strong>单词边界</strong>，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的<strong>开始位置</strong>。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的<strong>结束位置</strong>。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td>
</tr>
</tbody></table>
<h3 id="2-3特殊字符"><a href="#2-3特殊字符" class="headerlink" title="2.3特殊字符"></a>2.3特殊字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，也就是一般所说的元字符。如上面例子中的<code>*</code>等。如果需要查找字符串中的元字符，则需要在字符前加<code>\</code>进行转义。</p>
<p>例如：<code>deerchao\.net匹配deerchao.net，C:\\Windows匹配C:\Windows</code>。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>( )</td>
<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始。要匹配 [，请使用<code> \[</code>。</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如，<code> &#39;n&#39;</code> 匹配字符 ‘n’。<code>&#39;\n&#39;</code> 匹配换行符。序列 <code>&#39;\\&#39;</code> 匹配 <code>&quot;\&quot;</code>，而<code> &#39;\(&#39;</code> 则匹配 <code>&quot;(&quot;</code>。</td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始。要匹配 {，请使用 <code>\&#123;</code>。</td>
</tr>
<tr>
<td>|</td>
<td>指明两项之间的一个选择。要匹配 |，请使用 <code>|</code>。</td>
</tr>
</tbody></table>
<h3 id="2-4限定符-重复表示"><a href="#2-4限定符-重复表示" class="headerlink" title="2.4限定符 | 重复表示"></a>2.4限定符 | 重复表示</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。如下表：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前面的子表达式<strong>零次或多次</strong>。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式<strong>一次或多次</strong>。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式<strong>零次或一次</strong>。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。<strong>匹配确定的 n 次</strong>。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。<strong>至少</strong>匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;= m。<strong>最少匹配 n 次且最多匹配 m 次</strong>。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<h3 id="2-5反义"><a href="#2-5反义" class="headerlink" title="2.5反义"></a>2.5反义</h3><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意<strong>不是空白符</strong>的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意<strong>非数字</strong>的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配<strong>不是单词开头或结束</strong>的位置</td>
</tr>
<tr>
<td>[^x]</td>
<td>匹配<strong>除了x以外</strong>的任意字符</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody></table>
<p>举例：</p>
<ul>
<li><code>\S+</code>：匹配不包含空白字符的字符串</li>
<li><code>&lt;a[^&gt;]+&gt;</code>：匹配用尖括号括起来的，以a开头的字符串。（方括号中表示不包含<code>&gt;</code>）</li>
</ul>
<h3 id="2-6分支条件"><a href="#2-6分支条件" class="headerlink" title="2.6分支条件"></a>2.6分支条件</h3><p>分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配。具体方法是使用<code>|</code>把不同的规则分开。举例如下：</p>
<ul>
<li><p><code>0\d&#123;2&#125;-\d&#123;8&#125;|0\d&#123;3&#125;-\d&#123;7&#125;</code>：可以匹配到两种电话号码，如：012-23456433，或0233-3345329。</p>
</li>
<li><p><code>\(0\d&#123;2&#125;\)[- ]?\d&#123;8&#125;|0\d&#123;2&#125;[- ]?\d&#123;8&#125;</code>：可以匹配(023)-34553432,或023-84957362,且区号和本地号码间可以不存在连接符。</p>
</li>
</ul>
<p><strong>TIPS：使用分支条件时，需要注意各个条件之间的顺序。</strong></p>
<ul>
<li><code>\d&#123;5&#125;-\d&#123;4&#125;|\d&#123;5&#125;</code>：表示美国的邮政编码，5位数字或者使用连接符拼接的9位数字。然而当分支条件顺序调换：</li>
<li><code>\d&#123;5&#125;|\d&#123;5&#125;-\d&#123;4&#125;</code>：那么只能匹配到5位数字了，永远不会匹配到9位的编码，因为匹配顺序从左到右，满足了前面的分支后就不会再处理其他条件了。</li>
</ul>
<h3 id="2-7分组"><a href="#2-7分组" class="headerlink" title="2.7分组"></a>2.7分组</h3><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？可以用<strong>小括号</strong>来指定**子表达式(也叫做分组)**，然后指定这个子表达式的重复次数。举例：</p>
<p><code>(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;</code>：一个简单的IP地址匹配。<code>\d&#123;1,3&#125;\.</code>匹配三个数字加上一个英文句号，被括号括起来表示一个分组后面接上<code>&#123;3&#125;</code>表示这个分组重复三次，最后再加上一个三位的数字。不过以上的匹配没有限制IP地址不可以大于255，更进一步：</p>
<p><code>((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)</code></p>
<p>focus on:<code>2[0-4]\d|25[0-5]|[01]?\d\d?</code></p>
<h2 id="3-拓展学习"><a href="#3-拓展学习" class="headerlink" title="3.拓展学习"></a>3.拓展学习</h2><h3 id="3-1运算符优先级"><a href="#3-1运算符优先级" class="headerlink" title="3.1运算符优先级"></a>3.1运算符优先级</h3><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p>
<p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。如下表所示：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td><code>(), (?:), (?=), []</code></td>
<td>圆括号和方括号</td>
</tr>
<tr>
<td>*, +, ?, {n}, {n,}, {n,m}</td>
<td>限定符</td>
</tr>
<tr>
<td>^, $, \任何元字符、任何字符</td>
<td>定位点和序列（即：位置和顺序）</td>
</tr>
<tr>
<td>|</td>
<td>替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td>
</tr>
</tbody></table>
<h3 id="3-2匹配规则"><a href="#3-2匹配规则" class="headerlink" title="3.2匹配规则"></a>3.2匹配规则</h3><h4 id="3-2-1基本模式匹配"><a href="#3-2-1基本模式匹配" class="headerlink" title="3.2.1基本模式匹配"></a>3.2.1基本模式匹配</h4><p>模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^once</span><br></pre></td></tr></table></figure>

<p>这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bucket$</span><br></pre></td></tr></table></figure>

<p>这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符^和$同时使用时，表示精确匹配（字符串与模式一样）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^bucket$</span><br></pre></td></tr></table></figure>

<p>只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">once</span><br></pre></td></tr></table></figure>

<p>与字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There once was a man from NewYork</span><br><span class="line">Who kept all of his cash in a bucket.</span><br></pre></td></tr></table></figure>

<p>是匹配的。</p>
<p>在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠()打头。制表符的转义序列是：\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\t </span><br></pre></td></tr></table></figure>

<p>类似的，用\n表示”新行”，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\表示，句号.用.表示，以此类推。</p>
<h4 id="3-2-2字符簇"><a href="#3-2-2字符簇" class="headerlink" title="3.2.2字符簇"></a>3.2.2字符簇</h4><p>在INTERNET的程序中，正则表达式通常用来验证用户的输入。当用户提交一个FORM以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。</p>
<p>下面这个例子与任何元音字符匹配，但只能表示一个字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AaEeIiOoUu]</span><br></pre></td></tr></table></figure>

<p>用连字号可以表示一个字符的范围，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a-z] //匹配所有的小写字母 </span><br><span class="line">[A-Z] //匹配所有的大写字母 </span><br><span class="line">[a-zA-Z] //匹配所有的字母 </span><br><span class="line">[0-9] //匹配所有的数字 </span><br><span class="line">[0-9\.\-] //匹配所有的数字，句号和减号 </span><br><span class="line">[ \f\r\t\n] //匹配所有的白字符</span><br></pre></td></tr></table></figure>

<p>同样的，<strong>这些也只表示一个字符</strong>。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如”z2”、”t6”或”g7”，但不是”ab2”、”r2d3” 或”b52”的话，用这个模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[a-z][0-9]$</span><br></pre></td></tr></table></figure>

<p>尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。</p>
<p>前面曾经提到<code>^</code>表示字符串的开头，但它还有另外一个含义。**当在一组方括号里使用^，它表示”非”或”排除”**的意思，常常用来剔除某个字符。前面的例子中，如果我们要求第一个字符不能是数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[^0-9][0-9]$</span><br></pre></td></tr></table></figure>

<p>这个模式与”&amp;5”、”g7”及”-2”是匹配的，但与”12”、”66”是不匹配的。下面是几个排除特定字符的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[^a-z] //除了小写字母以外的所有字符 </span><br><span class="line">[^\\\/\^] //除了(\)(/)(^)之外的所有字符 </span><br><span class="line">[^\&quot;\&#x27;] //除了双引号(&quot;)和单引号(&#x27;)之外的所有字符</span><br></pre></td></tr></table></figure>

<p>特殊字符”.” (点，句号)在正则表达式中用来表示除了”新行”之外的所有字符。所以模式”^.5$”与任何两个字符的、以数字5结尾和以其他非”新行”字符开头的字符串匹配。模式”.”可以匹配任何字符串，除了空串和只包括一个”新行”的字符串。</p>
<h4 id="3-2-3确定重复出现"><a href="#3-2-3确定重复出现" class="headerlink" title="3.2.3确定重复出现"></a>3.2.3确定重复出现</h4><p>以上两种匹配已经可以解决很多问题，但某些情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。</p>
<table>
<thead>
<tr>
<th>字符簇</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>^[a-zA-Z_]$</code></td>
<td>所有的字母和下划线</td>
</tr>
<tr>
<td><code>^[[:alpha:]]&#123;3&#125;$</code></td>
<td>所有的3个字母的单词</td>
</tr>
<tr>
<td>^a$</td>
<td>字母a</td>
</tr>
<tr>
<td>^a{4}$</td>
<td>aaaa</td>
</tr>
<tr>
<td>^a{2,4}$</td>
<td>aa,aaa或aaaa</td>
</tr>
<tr>
<td>^a{1,3}$</td>
<td>a,aa或aaa</td>
</tr>
<tr>
<td>^a{2,}$</td>
<td>包含多于两个a的字符串</td>
</tr>
<tr>
<td>^a{2,}</td>
<td>如：aardvark和aaab，但apple不行</td>
</tr>
<tr>
<td>a{2,}</td>
<td>如：baad和aaa，但Nantucket不行</td>
</tr>
<tr>
<td>\t{2}</td>
<td>两个制表符</td>
</tr>
<tr>
<td>.{2}</td>
<td>所有的两个字符</td>
</tr>
</tbody></table>
<p>这些例子描述了花括号的三种不同的用法。一个数字 {x} 的意思是<strong>前面的字符或字符簇只出现x次</strong> ；一个数字加逗号 {x,} 的意思是<strong>前面的内容出现x或更多的次数</strong> ；两个数字用逗号分隔的数字 {x,y} 表示 <strong>前面的内容至少出现x次，但不超过y次</strong>。我们可以把模式扩展到更多的单词或数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[a-zA-Z0-9_]&#123;1,&#125;$      // 所有包含一个以上的字母、数字或下划线的字符串 </span><br><span class="line">^[1-9][0-9]&#123;0,&#125;$        // 所有的正整数 </span><br><span class="line">^\-&#123;0,1&#125;[0-9]&#123;1,&#125;$      // 所有的整数 </span><br><span class="line">^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数</span><br></pre></td></tr></table></figure>

<p>特殊字符 ? 与 {0,1} 是相等的，它们都代表着： <strong>0个或1个前面的内容</strong> 或 <strong>前面的内容是可选的</strong> 。</p>
<p>特殊字符 * 与 {0,} 是相等的，它们都代表着 <strong>0 个或多个前面的内容</strong> 。</p>
<p>特殊字符 + 与 {1,} 是相等的，表示 <strong>1 个或多个前面的内容</strong> ，所以上面的4个例子可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[a-zA-Z0-9_]+$      // 所有包含一个以上的字母、数字或下划线的字符串 </span><br><span class="line">^[1-9][0-9]*$        // 所有的正整数 </span><br><span class="line">^\-?[0-9]+$          // 所有的整数 </span><br><span class="line">^[-]?[0-9]+(\.[0-9]+)?$ // 所有的浮点数</span><br></pre></td></tr></table></figure>

<h3 id="3-3-java中的正则表达式"><a href="#3-3-java中的正则表达式" class="headerlink" title="3.3 java中的正则表达式"></a>3.3 java中的正则表达式</h3><p>在其他语言中，<code>\\ </code>表示：<strong>我想要在正则表达式中插入一个普通的（字面上的）反斜杠，没有任何特殊的意义。</strong></p>
<p>在 Java 中，<code>\\</code> 表示：<strong>我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。</strong></p>
<p>所以，在其他的语言中（如Perl），一个反斜杠 \ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 <code>\\</code> 代表其他语言中的一个 \，所以在Java语言中**表示一位数字的正则表达式是 <code>\\d</code>，而表示一个普通的反斜杠是 <code>\\\\</code>**。</p>
<h4 id="3-4-高级语法"><a href="#3-4-高级语法" class="headerlink" title="3.4 高级语法"></a>3.4 高级语法</h4><p>一些不太常用的不再详细列举，参考文末的正则表达式30分钟入门。</p>
<ul>
<li>后向引用</li>
<li>零宽断言 &amp; 负向零宽断言</li>
<li>贪婪与懒惰</li>
</ul>
<h2 id="4-元字符集合"><a href="#4-元字符集合" class="headerlink" title="4.元字符集合"></a>4.元字符集合</h2><p>正则表达式的完整元字符整理参考下方链接：</p>
<p><a href="http://www.runoob.com/regexp/regexp-metachar.html">正则表达式元字符</a></p>
<blockquote>
<p>本文参考文章：</p>
<p><a href="https://deerchao.net/tutorials/regex/regex.htm#mission">正则表达四30分钟入门</a></p>
<p><a href="http://www.runoob.com/regexp/regexp-tutorial.html">菜鸟正则表达式教程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java.io包之Bits类源码</title>
    <url>/2019/04/22/java.io%E5%8C%85%E4%B9%8BBits%E7%B1%BB%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>Bits为Default类型，非public类型，只可以被java.io包下的类引用。所以在实际coding中并不会用到这个类。在Bits类中方法均为static类型，通过类名进行访问，主要作为支持方法发挥作用。</p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Utility methods for packing/unpacking primitive values in/out of byte arrays using big-endian byte ordering.</p>
</blockquote>
<p>在Bits类开头有这么一段描述：一种通过big-endian字节序封装、解封原始数值进、出字节数组的高效方法。</p>
<p><strong>那么什么是big-endian(大端字节序)呢？</strong></p>
<p>字节序为大于一个字节大小的数据在内存中的存储顺序（你可以理解为字节为内存最小单元的大小），一般来说一个数据的存储空间在内存中是相邻的，对于CPU读取时，需要辨别多个存储单元所存储数据的顺序，顺序错了可能会得到完全不一样的数据。</p>
<p>计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。</p>
<ul>
<li><strong>大端字节序</strong>：高位字节在前，低位字节在后。（这是人类读写数值的方法）</li>
<li><strong>小端字节序</strong>：低位字节在前，高位字节在后</li>
</ul>
<p>举一个例子，数值<code>0x2211</code>使用两个字节保存：高位字节<code>0x22</code>，低位字节<code>0x11</code>，则大端字节序在内存中保存形式为<code>0x2211</code>，以小端字节序保存则为<code>0x1122</code>的形式。</p>
<p>关于字节序的进一步理解可以参考阮一峰老师的博客：<a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html">理解字节序</a></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>概览Bits类的源码可以发现所有方法均为getXXX 或 putXXX互为逆过程。以最简单的byte - short转换为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由byte数组类型 --&gt; short </span></span><br><span class="line"><span class="comment"> * short为两个字节，读取两个Byte共16Bits，由于是大端字节序：</span></span><br><span class="line"><span class="comment"> * b[off]数据的高8位 --&gt; 左位移8位到最终位置。</span></span><br><span class="line"><span class="comment"> * b[off+1]数据的低8位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">short</span>) ((b[off + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) +</span><br><span class="line">                    (b[off] &lt;&lt; <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 与get相反由short --&gt; byte数组类型</span></span><br><span class="line"><span class="comment">* 截取val右8bits作为低位存入b[off +1]</span></span><br><span class="line"><span class="comment">* val无符号右移8位后截取右8bits作为高位存入b[off]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putShort</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">short</span> val)</span> </span>&#123;</span><br><span class="line">	b[off + <span class="number">1</span>] = (<span class="keyword">byte</span>) (val      );</span><br><span class="line">    b[off    ] = (<span class="keyword">byte</span>) (val &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块源码看起来比较简单，但是深究起来还是有地方需要理解例如：<strong>为什么需要&amp; 0xFF?</strong></p>
<p>网上乱七八糟的写法一堆，还是要回到计算机组成原理最基础的开始。本文不深入介绍为什么计算机在运算过程中使用补码格式，详细可以参考 <a href="http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">原码反码补码详解</a>，<a href="https://blog.csdn.net/u011080472/article/details/51280919">大数据溢出问题</a>；我们需要了解：</p>
<ol>
<li>计算机使用补码形式进行计算；</li>
<li>正数的原码、反码、补码相同；</li>
<li>负数的反码：原码的除符号位外取反；</li>
<li>负数的补码：反码做+1运算；</li>
</ol>
<p>除此之外还需要注意Java在二元运算中数据类型的自动提升：(以下按优先级顺序转化)</p>
<ol>
<li>如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。 </li>
<li>如果其中一个操作数是float类型，另一个将会转换为float类型。</li>
<li>如果其中一个操作数是long类型，另一个会转换为long类型。 </li>
<li>否则：两个操作数都转换为int类型。（意思是：<strong>如果在二元操作中，不存在double，float，long的话，那么byte、short、char类型都会被转化为int类型</strong>）</li>
</ol>
<p>现在通过一个例子看一做&amp;0xFF的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用补码存储：</span></span><br><span class="line"><span class="comment">         * -127 -&gt; 原码：1111 1111，第一位是符号位；</span></span><br><span class="line"><span class="comment">         *      -&gt; 反码：1000 0000，除了符号位外做取反</span></span><br><span class="line"><span class="comment">         *      -&gt; 补码：1000 0001，对反码做+1运算</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a[<span class="number">0</span>] = -<span class="number">127</span>;</span><br><span class="line">        System.out.println(a[<span class="number">0</span>]); <span class="comment">//输出：-127</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 以二进制形式输出：111111111111111111111111 1000 0001，</span></span><br><span class="line"><span class="comment">        * 转为int类型，以符号位：1，自动补全至32位</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(Integer.toBinaryString(a[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 0xff十六进制一个字节8位：1111 1111</span></span><br><span class="line"><span class="comment">         * 发现会出现byte输出到int类型时会自动补齐至32位：</span></span><br><span class="line"><span class="comment">         *  1111 1111 1111 1111 1111 1111 1000 0001 &amp;</span></span><br><span class="line"><span class="comment">         * (0000 0000 0000 0000 0000 0000)1111 1111</span></span><br><span class="line"><span class="comment">         * -&gt;</span></span><br><span class="line"><span class="comment">         *  0000 0000 0000 0000 0000 0000 1000 0001 = 129</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = a[<span class="number">0</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*************************************/</span></span><br><span class="line">        <span class="comment">/**高位b[0]为：</span></span><br><span class="line"><span class="comment">         * 127 -&gt; 0000 0000 0000 0000 0000 0000 0111 1111 &lt;&lt; 8</span></span><br><span class="line"><span class="comment">         *       =0000 0000 0000 0000 0111 1111 0000 0000</span></span><br><span class="line"><span class="comment">         * 低位b[1]为：</span></span><br><span class="line"><span class="comment">         * -127-&gt; 1111 1111 1111 1111 1111 1111 1000 0001 &amp; 0xff</span></span><br><span class="line"><span class="comment">         *       =0000 0000 0000 0000 0000 0000 1000 0001</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *    0000 0000 0000 0000 0111 1111 0000 0000</span></span><br><span class="line"><span class="comment">         *  + 0000 0000 0000 0000 0000 0000 1000 0001</span></span><br><span class="line"><span class="comment">         *  = 0000 0000 0000 0000 0111 1111 1000 0001 =32641</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果不做 &amp; 0xff的运算，低位b[1]在二元运算中数据类型得到提升时会补1：</span></span><br><span class="line"><span class="comment">         * 高位b[0]为：</span></span><br><span class="line"><span class="comment">         * 127 -&gt; 0000 0000 0000 0000 0000 0000 0111 1111 &lt;&lt; 8</span></span><br><span class="line"><span class="comment">         *       =0000 0000 0000 0000 0111 1111 0000 0000</span></span><br><span class="line"><span class="comment">         * 低位b[1]为：</span></span><br><span class="line"><span class="comment">         * -127-&gt; 1111 1111 1111 1111 1111 1111 1000 0001</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      0000 0000 0000 0000 0111 1111 0000 0000</span></span><br><span class="line"><span class="comment">         *    + 1111 1111 1111 1111 1111 1111 1000 0001 运算中溢出一位</span></span><br><span class="line"><span class="comment">         *   (1)0000 0000 0000 0000 0111 1110 1000 0001 = 32385</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BitsTest test = <span class="keyword">new</span> BitsTest();</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">127</span>;</span><br><span class="line">        b[<span class="number">1</span>] = -<span class="number">127</span>;</span><br><span class="line">        System.out.println(test.getShort(b,<span class="number">0</span>)); <span class="comment">//输出：32641</span></span><br><span class="line">        System.out.println(test.getShort2(b,<span class="number">0</span>)); <span class="comment">//输出：32385</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">getShort</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>)((b[off] &lt;&lt; <span class="number">8</span>) +</span><br><span class="line">                (b[off +<span class="number">1</span>] &amp; <span class="number">0xFF</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">getShort2</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>)((b[off] &lt;&lt; <span class="number">8</span>) +</span><br><span class="line">                (b[off +<span class="number">1</span>] ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的例子可以发现，进行&amp; 0xFF最大的作用是：<strong>消除运算中类型自动升级导致补码符号位的影响。</strong></p>
<p>否则会由于符号位参与导致最终结果与期望不一致，换言之，在byte数组转化过程中我们只需要<strong>每一个字节8bits的二进制表示</strong>，而不需要自动补全的符号位。在JDK源码中有很多地方均有使用到&amp; 0xFF运算。</p>
<p>同理，在进行put操作时源码中使用了无符号右移操作(&gt;&gt;&gt;)，不过这一块有点奇怪，根据java的运算规则，char双字节转换为byte类型会进行截取操作，所以无论是有符号右移&gt;&gt;还是无符号都不会影响到字节数组的结果。不知道是不是为了严谨才这么写的~ :sweat:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putShort</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">short</span> val)</span> </span>&#123;</span><br><span class="line">	b[off + <span class="number">1</span>] = (<span class="keyword">byte</span>) (val      );</span><br><span class="line">    b[off    ] = (<span class="keyword">byte</span>) (val &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/xiaochunyong/article/details/7748713">java中的位运算</a></p>
<p><a href="https://blog.csdn.net/zhaominpro/article/details/79602381">Java中byte做&amp;oxff运算的原因及解析</a>：这一片文章从另一个角度讲了一下，我觉得也很值得一读。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JDK源码</category>
      </categories>
  </entry>
  <entry>
    <title>关于失恋，学着move on</title>
    <url>/2021/12/06/%E5%85%B3%E4%BA%8E%E5%A4%B1%E6%81%8B%EF%BC%8C%E5%AD%A6%E7%9D%80move-on/</url>
    <content><![CDATA[<blockquote>
<p>I’m not strong enough to do it in persons.<br>I realize now that I’m attracted to you, For the same reason I can’t be with you.<br>You can’t change.<br>And I have no problem with that, But it clearly means I have a problem with myself.<br>I’m sure there’s no perfect version of me.<br>I’m sure I’ll just unify species after species.<br>And never really be complete.<br>Bue I know how it goes with us.<br>I lose who I am and become part of you.<br>Because in a strange way, You’re better at what I do without even trying.<br>Yours, and nobody else’s, Unity. </p>
</blockquote>
<span id="more"></span>

<h1 id="📖我要做些什么"><a href="#📖我要做些什么" class="headerlink" title="📖我要做些什么"></a>📖我要做些什么</h1><p>1）承认现实💔：已经分手，不要再心存幻想<br>2）承认情绪😫：面对愤怒、悲伤、不甘，面对它，承认它<br>3）行动清单⬆️：运动 读书 旅行 购物 学习 工作<br>4）找到伙伴👬：互相监督，一起进步，面对未来，封存过去</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>失恋</tag>
        <tag>情感</tag>
      </tags>
  </entry>
</search>
